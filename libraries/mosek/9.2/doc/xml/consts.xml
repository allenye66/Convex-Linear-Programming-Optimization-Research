<?xml version="1.0"?>
<!--
  Copyright: $$copyright 
  
  File: consts.xml
  
  Purpose: Lists all constants in Mosek.
  -->


<!--
  This file lists all constants and parameters used in Mosek.


  THE FORMAT OF THIS FILE

  <mosekvalues>
    descr: The document root.
    
  <version>
    elements: <major> <minor> <build> <revision> <state>
    descr: Mosek version corresponding to the content of this file.

  <major>, <minor>, <build>, <revision>
    descr: An Integer representing the version.
    
  <state>
    descr: A string representing the version state 

  <constlist>
    elements: <sec>
    descr: This contains all Mosek constant groups.

  <sec>
    attributes:
      id: The name of the constants group as found in "mosek.h"
      type: String indicating the meaning of the constants. It is
        either "enum" (indicating that the group appears as an enum in
        "mosek.h"), "constants" (meaning a logical grouping of
        constants sharing the same prefix) or "parameter" (represents
        a type of parameters).
    elements: <c> <p>
    descr: Represents a group of constants.

  <c>
    attributes:
      name: The name of the constant
      val: The value of the constant
    elements: <cmnt> <seealso>
    descr: Represents a single constant value.

  <p>
    attributes:
      name: The name of the parameter
      val: The value of the constant representing the parameter (not the value of the parameter)
    elements: <cmnt> <default> <lower_bound> <upper_bound> <values_from> <seealso>
    descr: Represents a single parameter.

  <cmnt>
    descr: Text (LaTeX) description of the item.

  <seealso key="KEY">
    Link to other items relevant for this item. The element is empty.

  <default>
    descr: The default value of a parameter

  <lower_bound>
    descr: The lower bound on values for a parameter

  <upper_bound>
    descr: The upper bound on values for a parameter

  <values_from>
    descr: The parameter takes its values from the constant group of this name.
  -->


<mosekvalues>
<version>
 <major>9</major>
 <minor>2</minor>
 <build>0</build>
 <revision>25</revision>
 <state></state>
</version>

<constlist>
 <sec id="MSKbasindtypee" type="constants">
  <cmnt>Basis identification</cmnt>
  <c name="MSK_BI_NEVER" val="0">
   <cmnt>Never do basis identification.</cmnt>
  </c>
  <c name="MSK_BI_ALWAYS" val="1">
   <cmnt>Basis identification is always performed even if the interior-point optimizer terminates abnormally.</cmnt>
  </c>
  <c name="MSK_BI_NO_ERROR" val="2">
   <cmnt>Basis identification is performed if the interior-point optimizer terminates without an error.</cmnt>
  </c>
  <c name="MSK_BI_IF_FEASIBLE" val="3">
   <cmnt>Basis identification is not performed if the interior-point optimizer terminates with a problem status saying that the problem is primal or dual infeasible.</cmnt>
  </c>
  <c name="MSK_BI_RESERVERED" val="4">
   <cmnt>Not currently in use.</cmnt>
  </c>
 </sec>
 <sec id="MSKboundkeye" type="enum">
  <cmnt>Bound keys</cmnt>
  <c name="MSK_BK_LO" val="0">
   <cmnt>The constraint or variable has a finite lower bound and an infinite upper bound.</cmnt>
  </c>
  <c name="MSK_BK_UP" val="1">
   <cmnt>The constraint or variable has an infinite lower bound and an finite upper bound.</cmnt>
  </c>
  <c name="MSK_BK_FX" val="2">
   <cmnt>The constraint or variable is fixed.</cmnt>
  </c>
  <c name="MSK_BK_FR" val="3">
   <cmnt>The constraint or variable is free.</cmnt>
  </c>
  <c name="MSK_BK_RA" val="4">
   <cmnt>The constraint or variable is ranged.</cmnt>
  </c>
 </sec>
 <sec id="MSKmarke" type="enum">
  <cmnt>Mark</cmnt>
  <c name="MSK_MARK_LO" val="0">
   <cmnt>The lower bound is selected for sensitivity analysis.</cmnt>
  </c>
  <c name="MSK_MARK_UP" val="1">
   <cmnt>The upper bound is selected for sensitivity analysis.</cmnt>
  </c>
 </sec>
 <sec id="MSKsimdegene" type="enum">
  <cmnt>Degeneracy strategies</cmnt>
  <c name="MSK_SIM_DEGEN_NONE" val="0">
   <cmnt>The simplex optimizer should use no degeneration strategy.</cmnt>
  </c>
  <c name="MSK_SIM_DEGEN_FREE" val="1">
   <cmnt>The simplex optimizer chooses the degeneration strategy.</cmnt>
  </c>
  <c name="MSK_SIM_DEGEN_AGGRESSIVE" val="2">
   <cmnt>The simplex optimizer should use an aggressive degeneration strategy.</cmnt>
  </c>
  <c name="MSK_SIM_DEGEN_MODERATE" val="3">
   <cmnt>The simplex optimizer should use a moderate degeneration strategy.</cmnt>
  </c>
  <c name="MSK_SIM_DEGEN_MINIMUM" val="4">
   <cmnt>The simplex optimizer should use a minimum degeneration strategy.</cmnt>
  </c>
 </sec>
 <sec id="MSKtransposee" type="enum">
  <cmnt>Transposed matrix.</cmnt>
  <c name="MSK_TRANSPOSE_NO" val="0">
   <cmnt>No transpose is applied.</cmnt>
  </c>
  <c name="MSK_TRANSPOSE_YES" val="1">
   <cmnt>A transpose is applied.</cmnt>
  </c>
 </sec>
 <sec id="MSKuploe" type="enum">
  <cmnt>Triangular part of a symmetric matrix.</cmnt>
  <c name="MSK_UPLO_LO" val="0">
   <cmnt>Lower part.</cmnt>
  </c>
  <c name="MSK_UPLO_UP" val="1">
   <cmnt>Upper part.</cmnt>
  </c>
 </sec>
 <sec id="MSKsimreforme" type="enum">
  <cmnt>Problem reformulation.</cmnt>
  <c name="MSK_SIM_REFORMULATION_ON" val="1">
   <cmnt>Allow the simplex optimizer to reformulate the problem.</cmnt>
  </c>
  <c name="MSK_SIM_REFORMULATION_OFF" val="0">
   <cmnt>Disallow the simplex optimizer to reformulate the problem.</cmnt>
  </c>
  <c name="MSK_SIM_REFORMULATION_FREE" val="2">
   <cmnt>The simplex optimizer can choose freely.</cmnt>
  </c>
  <c name="MSK_SIM_REFORMULATION_AGGRESSIVE" val="3">
   <cmnt>The simplex optimizer should use an aggressive reformulation strategy.</cmnt>
  </c>
 </sec>
 <sec id="MSKsimdupvece" type="enum">
  <cmnt>Exploit duplicate columns.</cmnt>
  <c name="MSK_SIM_EXPLOIT_DUPVEC_ON" val="1">
   <cmnt>Allow the simplex optimizer to exploit duplicated columns.</cmnt>
  </c>
  <c name="MSK_SIM_EXPLOIT_DUPVEC_OFF" val="0">
   <cmnt>Disallow the simplex optimizer to exploit duplicated columns.</cmnt>
  </c>
  <c name="MSK_SIM_EXPLOIT_DUPVEC_FREE" val="2">
   <cmnt>The simplex optimizer can choose freely.</cmnt>
  </c>
 </sec>
 <sec id="MSKsimhotstarte" type="enum">
  <cmnt>Hot-start type employed by the simplex optimizer</cmnt>
  <c name="MSK_SIM_HOTSTART_NONE" val="0">
   <cmnt>The simplex optimizer performs a coldstart.</cmnt>
  </c>
  <c name="MSK_SIM_HOTSTART_FREE" val="1">
   <cmnt>The simplex optimize chooses the hot-start type.</cmnt>
  </c>
  <c name="MSK_SIM_HOTSTART_STATUS_KEYS" val="2">
   <cmnt>Only the status keys of the constraints and variables are used to choose the type of hot-start.</cmnt>
  </c>
 </sec>
 <sec id="MSKintpnthotstarte" type="enum">
  <cmnt>Hot-start type employed by the interior-point optimizers.</cmnt>
  <c name="MSK_INTPNT_HOTSTART_NONE" val="0">
   <cmnt>The interior-point optimizer performs a coldstart.</cmnt>
  </c>
  <c name="MSK_INTPNT_HOTSTART_PRIMAL" val="1">
   <cmnt>The interior-point optimizer exploits the primal solution only.</cmnt>
  </c>
  <c name="MSK_INTPNT_HOTSTART_DUAL" val="2">
   <cmnt>The interior-point optimizer exploits the dual solution only.</cmnt>
  </c>
  <c name="MSK_INTPNT_HOTSTART_PRIMAL_DUAL" val="3">
   <cmnt>The interior-point optimizer exploits both the primal and dual solution.</cmnt>
  </c>
 </sec>
 <sec id="MSKpurifye" type="enum">
  <cmnt>Solution purification employed optimizer.</cmnt>
  <c name="MSK_PURIFY_NONE" val="0">
   <cmnt>The optimizer performs no solution purification.</cmnt>
  </c>
  <c name="MSK_PURIFY_PRIMAL" val="1">
   <cmnt>The optimizer purifies the primal solution.</cmnt>
  </c>
  <c name="MSK_PURIFY_DUAL" val="2">
   <cmnt>The optimizer purifies the dual solution.</cmnt>
  </c>
  <c name="MSK_PURIFY_PRIMAL_DUAL" val="3">
   <cmnt>The optimizer purifies both the primal and dual solution.</cmnt>
  </c>
  <c name="MSK_PURIFY_AUTO" val="4">
   <cmnt>TBD</cmnt>
  </c>
 </sec>
 <sec id="MSKcallbackcodee" type="enum">
  <cmnt>Progress callback codes</cmnt>
  <c name="MSK_CALLBACK_BEGIN_ROOT_CUTGEN" val="22">
   <cmnt>The callback function is called when root cut generation is started.</cmnt>
  </c>
  <c name="MSK_CALLBACK_IM_ROOT_CUTGEN" val="76">
   <cmnt>The callback is called from within root cut generation at an intermediate stage.</cmnt>
  </c>
  <c name="MSK_CALLBACK_END_ROOT_CUTGEN" val="51">
   <cmnt>The callback function is called when root cut generation is terminated.</cmnt>
  </c>
  <c name="MSK_CALLBACK_BEGIN_OPTIMIZER" val="12">
   <cmnt>The callback function is called when the optimizer is started.</cmnt>
  </c>
  <c name="MSK_CALLBACK_END_OPTIMIZER" val="41">
   <cmnt>The callback function is called when the optimizer is terminated.</cmnt>
  </c>
  <c name="MSK_CALLBACK_BEGIN_PRESOLVE" val="13">
   <cmnt>The callback function is called when the presolve is started.</cmnt>
  </c>
  <c name="MSK_CALLBACK_UPDATE_PRESOLVE" val="88">
   <cmnt>The callback function is called from within the presolve procedure.</cmnt>
  </c>
  <c name="MSK_CALLBACK_IM_PRESOLVE" val="70">
   <cmnt>The callback function is called from within the presolve procedure at an intermediate stage.</cmnt>
  </c>
  <c name="MSK_CALLBACK_END_PRESOLVE" val="42">
   <cmnt>The callback function is called when the presolve is completed.</cmnt>
  </c>
  <c name="MSK_CALLBACK_BEGIN_INTPNT" val="9">
   <cmnt>The callback function is called when the interior-point optimizer is started.</cmnt>
  </c>
  <c name="MSK_CALLBACK_INTPNT" val="79">
   <cmnt>The callback function is called from within the interior-point optimizer after the information database has been updated.</cmnt>
  </c>
  <c name="MSK_CALLBACK_IM_INTPNT" val="62">
   <cmnt>The callback function is called at an intermediate stage within the interior-point optimizer where the information database has not been updated.</cmnt>
  </c>
  <c name="MSK_CALLBACK_END_INTPNT" val="38">
   <cmnt>The callback function is called when the interior-point optimizer is terminated.</cmnt>
  </c>
  <c name="MSK_CALLBACK_BEGIN_CONIC" val="1">
   <cmnt>The callback function is called when the conic optimizer is started.</cmnt>
  </c>
  <c name="MSK_CALLBACK_CONIC" val="27">
   <cmnt>The callback function is called from within the conic optimizer after the information database has been updated.</cmnt>
  </c>
  <c name="MSK_CALLBACK_IM_CONIC" val="57">
   <cmnt>The callback function is called at an intermediate stage within the conic optimizer where the information database has not been updated.</cmnt>
  </c>
  <c name="MSK_CALLBACK_END_CONIC" val="30">
   <cmnt>The callback function is called when the conic optimizer is terminated.</cmnt>
  </c>
  <c name="MSK_CALLBACK_PRIMAL_SIMPLEX" val="81">
   <cmnt>The callback function is called from within the primal simplex optimizer.</cmnt>
  </c>
  <c name="MSK_CALLBACK_DUAL_SIMPLEX" val="28">
   <cmnt>The callback function is called from within the dual simplex optimizer.</cmnt>
  </c>
  <c name="MSK_CALLBACK_BEGIN_BI" val="0">
   <cmnt>The basis identification procedure has been started.</cmnt>
  </c>
  <c name="MSK_CALLBACK_IM_BI" val="56">
   <cmnt>The callback function is called from within the basis identification procedure at an intermediate point.</cmnt>
  </c>
  <c name="MSK_CALLBACK_END_BI" val="29">
   <cmnt>The callback function is called when the basis identification procedure is terminated.</cmnt>
  </c>
  <c name="MSK_CALLBACK_BEGIN_PRIMAL_BI" val="14">
   <cmnt>The callback function is called from within the basis identification procedure when the primal phase is started.</cmnt>
  </c>
  <c name="MSK_CALLBACK_IM_PRIMAL_BI" val="71">
   <cmnt>The callback function is called from within the basis identification procedure at an intermediate point in the primal phase.</cmnt>
  </c>
  <c name="MSK_CALLBACK_UPDATE_PRIMAL_BI" val="89">
   <cmnt>The callback function is called from within the basis identification procedure at an intermediate point in the primal phase.</cmnt>
  </c>
  <c name="MSK_CALLBACK_END_PRIMAL_BI" val="43">
   <cmnt>The callback function is called from within the basis identification procedure when the primal phase is terminated.</cmnt>
  </c>
  <c name="MSK_CALLBACK_BEGIN_DUAL_BI" val="2">
   <cmnt>The callback function is called from within the basis identification procedure when the dual phase is started.</cmnt>
  </c>
  <c name="MSK_CALLBACK_IM_DUAL_BI" val="58">
   <cmnt>The callback function is called from within the basis identification procedure at an intermediate point in the dual phase.</cmnt>
  </c>
  <c name="MSK_CALLBACK_UPDATE_DUAL_BI" val="85">
   <cmnt>The callback function is called from within the basis identification procedure at an intermediate point in the dual phase.</cmnt>
  </c>
  <c name="MSK_CALLBACK_END_DUAL_BI" val="31">
   <cmnt>The callback function is called from within the basis identification procedure when the dual phase is terminated.</cmnt>
  </c>
  <c name="MSK_CALLBACK_BEGIN_SIMPLEX_BI" val="24">
   <cmnt>The callback function is called from within the basis identification procedure when the simplex clean-up phase is started.</cmnt>
  </c>
  <c name="MSK_CALLBACK_IM_SIMPLEX_BI" val="78">
   <cmnt>The callback function is called
from within the basis identification procedure
at an intermediate point in the simplex clean-up phase.
The frequency of the callbacks is controlled by the
:msk:iparam:`log_sim_freq` parameter.</cmnt>
  </c>
  <c name="MSK_CALLBACK_BEGIN_PRIMAL_SIMPLEX_BI" val="19">
   <cmnt>The callback function is called from within the basis identification procedure when the primal simplex clean-up phase is started.</cmnt>
  </c>
  <c name="MSK_CALLBACK_UPDATE_PRIMAL_SIMPLEX_BI" val="91">
   <cmnt>The callback function is called
from within the basis identification procedure
at an intermediate point in the primal simplex clean-up phase.
The frequency of the callbacks is controlled by the
:msk:iparam:`log_sim_freq` parameter.</cmnt>
  </c>
  <c name="MSK_CALLBACK_END_PRIMAL_SIMPLEX_BI" val="48">
   <cmnt>The callback function is called from within the basis identification procedure when the primal clean-up phase is terminated.</cmnt>
  </c>
  <c name="MSK_CALLBACK_BEGIN_DUAL_SIMPLEX_BI" val="6">
   <cmnt>The callback function is called from within the basis identification procedure when the dual simplex clean-up phase is started.</cmnt>
  </c>
  <c name="MSK_CALLBACK_UPDATE_DUAL_SIMPLEX_BI" val="87">
   <cmnt>The callback function is called from within the basis identification procedure at an intermediate point in the dual simplex clean-up phase.
The frequency of the callbacks is controlled by the :msk:iparam:`log_sim_freq` parameter.</cmnt>
  </c>
  <c name="MSK_CALLBACK_END_DUAL_SIMPLEX_BI" val="35">
   <cmnt>The callback function is called from within the basis identification procedure when the dual clean-up phase is terminated.</cmnt>
  </c>
  <c name="MSK_CALLBACK_END_SIMPLEX_BI" val="53">
   <cmnt>The callback function is called from within the basis identification procedure when the simplex clean-up phase is terminated.</cmnt>
  </c>
  <c name="MSK_CALLBACK_BEGIN_MIO" val="11">
   <cmnt>The callback function is called when the mixed-integer optimizer is started.</cmnt>
  </c>
  <c name="MSK_CALLBACK_IM_MIO" val="65">
   <cmnt>The callback function is called at an intermediate point in the mixed-integer optimizer.</cmnt>
  </c>
  <c name="MSK_CALLBACK_NEW_INT_MIO" val="80">
   <cmnt>The callback function is called after a new integer solution has been located by the mixed-integer optimizer.</cmnt>
  </c>
  <c name="MSK_CALLBACK_END_MIO" val="40">
   <cmnt>The callback function is called when the mixed-integer optimizer is terminated.</cmnt>
  </c>
  <c name="MSK_CALLBACK_BEGIN_SIMPLEX" val="23">
   <cmnt>The callback function is called when the simplex optimizer is started.</cmnt>
  </c>
  <c name="MSK_CALLBACK_BEGIN_DUAL_SIMPLEX" val="5">
   <cmnt>The callback function is called when the dual simplex optimizer started.</cmnt>
  </c>
  <c name="MSK_CALLBACK_IM_DUAL_SIMPLEX" val="60">
   <cmnt>The callback function is called at an intermediate point in the dual simplex optimizer.</cmnt>
  </c>
  <c name="MSK_CALLBACK_UPDATE_DUAL_SIMPLEX" val="86">
   <cmnt>The callback function is called in the dual simplex optimizer.</cmnt>
  </c>
  <c name="MSK_CALLBACK_END_DUAL_SIMPLEX" val="34">
   <cmnt>The callback function is called when the dual simplex optimizer is terminated.</cmnt>
  </c>
  <c name="MSK_CALLBACK_BEGIN_PRIMAL_SIMPLEX" val="18">
   <cmnt>The callback function is called when the primal simplex optimizer is started.</cmnt>
  </c>
  <c name="MSK_CALLBACK_IM_PRIMAL_SIMPLEX" val="73">
   <cmnt>The callback function is called at an intermediate point in the primal simplex optimizer.</cmnt>
  </c>
  <c name="MSK_CALLBACK_UPDATE_PRIMAL_SIMPLEX" val="90">
   <cmnt>The callback function is called  in the primal simplex optimizer.</cmnt>
  </c>
  <c name="MSK_CALLBACK_END_PRIMAL_SIMPLEX" val="47">
   <cmnt>The callback function is called when the primal simplex optimizer is terminated.</cmnt>
  </c>
  <c name="MSK_CALLBACK_END_SIMPLEX" val="52">
   <cmnt>The callback function is called when the simplex optimizer is terminated.</cmnt>
  </c>
  <c name="MSK_CALLBACK_BEGIN_INFEAS_ANA" val="8">
   <cmnt>The callback function is called when the infeasibility analyzer is started.</cmnt>
  </c>
  <c name="MSK_CALLBACK_END_INFEAS_ANA" val="37">
   <cmnt>The callback function is called when the infeasibility analyzer is terminated.</cmnt>
  </c>
  <c name="MSK_CALLBACK_IM_PRIMAL_SENSIVITY" val="72">
   <cmnt>The callback function is called at an intermediate stage of the primal sensitivity analysis.</cmnt>
  </c>
  <c name="MSK_CALLBACK_IM_DUAL_SENSIVITY" val="59">
   <cmnt>The callback function is called at an intermediate stage of the dual sensitivity analysis.</cmnt>
  </c>
  <c name="MSK_CALLBACK_IM_MIO_INTPNT" val="67">
   <cmnt>The callback function is called at an intermediate point in the mixed-integer optimizer while running the interior-point optimizer.</cmnt>
  </c>
  <c name="MSK_CALLBACK_IM_MIO_PRIMAL_SIMPLEX" val="68">
   <cmnt>The callback function is called at an intermediate point in the mixed-integer optimizer while running the primal simplex optimizer.</cmnt>
  </c>
  <c name="MSK_CALLBACK_IM_MIO_DUAL_SIMPLEX" val="66">
   <cmnt>The callback function is called at an intermediate point in the mixed-integer optimizer while running the dual simplex optimizer.</cmnt>
  </c>
  <c name="MSK_CALLBACK_BEGIN_PRIMAL_SETUP_BI" val="17">
   <cmnt>The callback function is called when the primal BI setup is started.</cmnt>
  </c>
  <c name="MSK_CALLBACK_END_PRIMAL_SETUP_BI" val="46">
   <cmnt>The callback function is called when the primal BI setup is terminated.</cmnt>
  </c>
  <c name="MSK_CALLBACK_BEGIN_DUAL_SETUP_BI" val="4">
   <cmnt>The callback function is called when the dual BI phase is started.</cmnt>
  </c>
  <c name="MSK_CALLBACK_END_DUAL_SETUP_BI" val="33">
   <cmnt>The callback function is called when the dual BI phase is terminated.</cmnt>
  </c>
  <c name="MSK_CALLBACK_BEGIN_PRIMAL_SENSITIVITY" val="16">
   <cmnt>Primal sensitivity analysis is started.</cmnt>
  </c>
  <c name="MSK_CALLBACK_END_PRIMAL_SENSITIVITY" val="45">
   <cmnt>Primal sensitivity analysis is terminated.</cmnt>
  </c>
  <c name="MSK_CALLBACK_BEGIN_DUAL_SENSITIVITY" val="3">
   <cmnt>Dual sensitivity analysis is started.</cmnt>
  </c>
  <c name="MSK_CALLBACK_END_DUAL_SENSITIVITY" val="32">
   <cmnt>Dual sensitivity analysis is terminated.</cmnt>
  </c>
  <c name="MSK_CALLBACK_BEGIN_LICENSE_WAIT" val="10">
   <cmnt>Begin waiting for license.</cmnt>
  </c>
  <c name="MSK_CALLBACK_END_LICENSE_WAIT" val="39">
   <cmnt>End waiting for license.</cmnt>
  </c>
  <c name="MSK_CALLBACK_IM_LICENSE_WAIT" val="63">
   <cmnt>|mosek| is waiting for a license.</cmnt>
  </c>
  <c name="MSK_CALLBACK_BEGIN_QCQO_REFORMULATE" val="20">
   <cmnt>Begin QCQO reformulation.</cmnt>
  </c>
  <c name="MSK_CALLBACK_END_QCQO_REFORMULATE" val="49">
   <cmnt>End QCQO reformulation.</cmnt>
  </c>
  <c name="MSK_CALLBACK_IM_QO_REFORMULATE" val="74">
   <cmnt>The callback function is called at an intermediate stage of the conic quadratic reformulation.</cmnt>
  </c>
  <c name="MSK_CALLBACK_BEGIN_TO_CONIC" val="25">
   <cmnt>Begin conic reformulation.</cmnt>
  </c>
  <c name="MSK_CALLBACK_END_TO_CONIC" val="54">
   <cmnt>End conic reformulation.</cmnt>
  </c>
  <c name="MSK_CALLBACK_BEGIN_FULL_CONVEXITY_CHECK" val="7">
   <cmnt>Begin full convexity check.</cmnt>
  </c>
  <c name="MSK_CALLBACK_END_FULL_CONVEXITY_CHECK" val="36">
   <cmnt>End full convexity check.</cmnt>
  </c>
  <c name="MSK_CALLBACK_IM_FULL_CONVEXITY_CHECK" val="61">
   <cmnt>The callback function is called at an intermediate stage of the full convexity check.</cmnt>
  </c>
  <c name="MSK_CALLBACK_BEGIN_PRIMAL_REPAIR" val="15">
   <cmnt>Begin primal feasibility repair.</cmnt>
  </c>
  <c name="MSK_CALLBACK_END_PRIMAL_REPAIR" val="44">
   <cmnt>End primal feasibility repair.</cmnt>
  </c>
  <c name="MSK_CALLBACK_BEGIN_READ" val="21">
   <cmnt>|mosek| has started reading a problem file.</cmnt>
  </c>
  <c name="MSK_CALLBACK_IM_READ" val="75">
   <cmnt>Intermediate stage in reading.</cmnt>
  </c>
  <c name="MSK_CALLBACK_END_READ" val="50">
   <cmnt>|mosek| has finished reading a problem file.</cmnt>
  </c>
  <c name="MSK_CALLBACK_BEGIN_WRITE" val="26">
   <cmnt>|mosek| has started writing a problem file.</cmnt>
  </c>
  <c name="MSK_CALLBACK_END_WRITE" val="55">
   <cmnt>|mosek| has finished writing a problem file.</cmnt>
  </c>
  <c name="MSK_CALLBACK_READ_OPF_SECTION" val="83">
   <cmnt>A chunk of :math:`Q` non-zeros has been read from a problem file.</cmnt>
  </c>
  <c name="MSK_CALLBACK_IM_LU" val="64">
   <cmnt>The callback function is called from within the LU factorization procedure at an intermediate point.</cmnt>
  </c>
  <c name="MSK_CALLBACK_IM_ORDER" val="69">
   <cmnt>The callback function is called from within the matrix ordering procedure at an intermediate point.</cmnt>
  </c>
  <c name="MSK_CALLBACK_IM_SIMPLEX" val="77">
   <cmnt>The callback function is called from within the simplex optimizer at an intermediate point.</cmnt>
  </c>
  <c name="MSK_CALLBACK_READ_OPF" val="82">
   <cmnt>The callback function is called from the OPF reader.</cmnt>
  </c>
  <c name="MSK_CALLBACK_WRITE_OPF" val="92">
   <cmnt>The callback function is called from the OPF writer.</cmnt>
  </c>
  <c name="MSK_CALLBACK_SOLVING_REMOTE" val="84">
   <cmnt>The callback function is called while the task is being solved on a remote server.</cmnt>
  </c>
 </sec>
 <sec id="MSKcheckconvexitytypee" type="constants">
  <cmnt>Types of convexity checks.</cmnt>
  <c name="MSK_CHECK_CONVEXITY_NONE" val="0">
   <cmnt>No convexity check.</cmnt>
  </c>
  <c name="MSK_CHECK_CONVEXITY_SIMPLE" val="1">
   <cmnt>Perform simple and fast convexity check.</cmnt>
  </c>
  <c name="MSK_CHECK_CONVEXITY_FULL" val="2">
   <cmnt>Perform a full convexity check.</cmnt>
  </c>
 </sec>
 <sec id="MSKcompresstypee" type="constants">
  <cmnt>Compression types</cmnt>
  <c name="MSK_COMPRESS_NONE" val="0">
   <cmnt>No compression is used.</cmnt>
  </c>
  <c name="MSK_COMPRESS_FREE" val="1">
   <cmnt>The type of compression used is chosen automatically.</cmnt>
  </c>
  <c name="MSK_COMPRESS_GZIP" val="2">
   <cmnt>The type of compression used is gzip compatible.</cmnt>
  </c>
  <c name="MSK_COMPRESS_ZSTD" val="3">
   <cmnt>The type of compression used is zstd compatible.</cmnt>
  </c>
 </sec>
 <sec id="MSKconetypee" type="enum">
  <cmnt>Cone types</cmnt>
  <c name="MSK_CT_QUAD" val="0">
   <cmnt>The cone is a quadratic cone.</cmnt>
  </c>
  <c name="MSK_CT_RQUAD" val="1">
   <cmnt>The cone is a rotated quadratic cone.</cmnt>
  </c>
  <c name="MSK_CT_PEXP" val="2">
   <cmnt>A primal exponential cone.</cmnt>
  </c>
  <c name="MSK_CT_DEXP" val="3">
   <cmnt>A dual exponential cone.</cmnt>
  </c>
  <c name="MSK_CT_PPOW" val="4">
   <cmnt>A primal power cone.</cmnt>
  </c>
  <c name="MSK_CT_DPOW" val="5">
   <cmnt>A dual power cone.</cmnt>
  </c>
  <c name="MSK_CT_ZERO" val="6">
   <cmnt>The zero cone.</cmnt>
  </c>
 </sec>
 <sec id="MSKnametypee" type="enum">
  <cmnt>Name types</cmnt>
  <c name="MSK_NAME_TYPE_GEN" val="0">
   <cmnt>General names. However, no duplicate and blank names are allowed.</cmnt>
  </c>
  <c name="MSK_NAME_TYPE_MPS" val="1">
   <cmnt>MPS type names.</cmnt>
  </c>
  <c name="MSK_NAME_TYPE_LP" val="2">
   <cmnt>LP type names.</cmnt>
  </c>
 </sec>
 <sec id="MSKscopre" type="enum">
  <cmnt>SCopt operator types</cmnt>
  <c name="MSK_OPR_ENT" val="0">
   <cmnt>Entropy</cmnt>
  </c>
  <c name="MSK_OPR_EXP" val="1">
   <cmnt>Exponential</cmnt>
  </c>
  <c name="MSK_OPR_LOG" val="2">
   <cmnt>Logarithm</cmnt>
  </c>
  <c name="MSK_OPR_POW" val="3">
   <cmnt>Power</cmnt>
  </c>
  <c name="MSK_OPR_SQRT" val="4">
   <cmnt>Square root</cmnt>
  </c>
 </sec>
 <sec id="MSKsymmattypee" type="enum">
  <cmnt>Cone types</cmnt>
  <c name="MSK_SYMMAT_TYPE_SPARSE" val="0">
   <cmnt>Sparse symmetric matrix.</cmnt>
  </c>
 </sec>
 <sec id="MSKdataformate" type="constants">
  <cmnt>Data format types</cmnt>
  <c name="MSK_DATA_FORMAT_EXTENSION" val="0">
   <cmnt>The file extension is used to determine the data file format.</cmnt>
  </c>
  <c name="MSK_DATA_FORMAT_MPS" val="1">
   <cmnt>The data file is MPS formatted.</cmnt>
  </c>
  <c name="MSK_DATA_FORMAT_LP" val="2">
   <cmnt>The data file is LP formatted.</cmnt>
  </c>
  <c name="MSK_DATA_FORMAT_OP" val="3">
   <cmnt>The data file is an optimization problem formatted file.</cmnt>
  </c>
  <c name="MSK_DATA_FORMAT_FREE_MPS" val="4">
   <cmnt>The data a free MPS formatted file.</cmnt>
  </c>
  <c name="MSK_DATA_FORMAT_TASK" val="5">
   <cmnt>Generic task dump file.</cmnt>
  </c>
  <c name="MSK_DATA_FORMAT_PTF" val="6">
   <cmnt>(P)retty (T)ext (F)format.</cmnt>
  </c>
  <c name="MSK_DATA_FORMAT_CB" val="7">
   <cmnt>Conic benchmark format,</cmnt>
  </c>
  <c name="MSK_DATA_FORMAT_JSON_TASK" val="8">
   <cmnt>JSON based task format.</cmnt>
  </c>
 </sec>
 <sec id="MSKdinfiteme" type="enum">
  <cmnt>Double information items</cmnt>
  <c name="MSK_DINF_BI_TIME" val="5">
   <cmnt>Time spent within the basis identification procedure since its invocation.</cmnt>
  </c>
  <c name="MSK_DINF_BI_PRIMAL_TIME" val="4">
   <cmnt>Time  spent within the primal phase of the basis identification procedure since its invocation.</cmnt>
  </c>
  <c name="MSK_DINF_BI_DUAL_TIME" val="3">
   <cmnt>Time spent within the dual phase basis identification procedure since its invocation.</cmnt>
  </c>
  <c name="MSK_DINF_BI_CLEAN_TIME" val="2">
   <cmnt>Time spent within the clean-up phase of the basis identification procedure since its invocation.</cmnt>
  </c>
  <c name="MSK_DINF_BI_CLEAN_PRIMAL_TIME" val="1">
   <cmnt>Time spent within the primal clean-up optimizer of the basis identification procedure since its invocation.</cmnt>
  </c>
  <c name="MSK_DINF_BI_CLEAN_DUAL_TIME" val="0">
   <cmnt>Time  spent within the dual clean-up optimizer of the basis identification procedure since its invocation.</cmnt>
  </c>
  <c name="MSK_DINF_INTPNT_TIME" val="13">
   <cmnt>Time spent within the interior-point optimizer since its invocation.</cmnt>
  </c>
  <c name="MSK_DINF_INTPNT_ORDER_TIME" val="10">
   <cmnt>Order time (in seconds).</cmnt>
  </c>
  <c name="MSK_DINF_INTPNT_PRIMAL_OBJ" val="12">
   <cmnt>Primal objective value reported by the interior-point optimizer.</cmnt>
  </c>
  <c name="MSK_DINF_INTPNT_DUAL_OBJ" val="7">
   <cmnt>Dual objective value reported by the interior-point optimizer.</cmnt>
  </c>
  <c name="MSK_DINF_INTPNT_PRIMAL_FEAS" val="11">
   <cmnt>Primal feasibility measure reported by the interior-point optimizer. (For the interior-point optimizer this measure is not directly related to the original problem because a homogeneous model is employed).</cmnt>
  </c>
  <c name="MSK_DINF_INTPNT_DUAL_FEAS" val="6">
   <cmnt>Dual feasibility measure reported by the interior-point optimizer. (For the interior-point optimizer this measure is not directly related to the original problem because a homogeneous model is employed.)</cmnt>
  </c>
  <c name="MSK_DINF_INTPNT_OPT_STATUS" val="9">
   <cmnt>A measure of optimality of the solution. It should converge to :math:`+1` if the problem has a primal-dual optimal solution, and converge to :math:`-1` if the problem is (strictly) primal or dual infeasible. If the measure converges to another constant, or fails to settle, the problem is usually ill-posed.</cmnt>
  </c>
  <c name="MSK_DINF_SIM_TIME" val="45">
   <cmnt>Time spent in the simplex optimizer since invoking it.</cmnt>
  </c>
  <c name="MSK_DINF_SIM_PRIMAL_TIME" val="44">
   <cmnt>Time spent in the primal simplex optimizer since invoking it.</cmnt>
  </c>
  <c name="MSK_DINF_SIM_DUAL_TIME" val="41">
   <cmnt>Time spent in the dual simplex optimizer since invoking it.</cmnt>
  </c>
  <c name="MSK_DINF_SIM_OBJ" val="43">
   <cmnt>Objective value reported by the simplex optimizer.</cmnt>
  </c>
  <c name="MSK_DINF_SIM_FEAS" val="42">
   <cmnt>Feasibility measure reported by the simplex optimizer.</cmnt>
  </c>
  <c name="MSK_DINF_MIO_TIME" val="29">
   <cmnt>Time spent in the mixed-integer optimizer.</cmnt>
  </c>
  <c name="MSK_DINF_MIO_ROOT_PRESOLVE_TIME" val="28">
   <cmnt>Time spent presolving the problem at the root node.</cmnt>
  </c>
  <c name="MSK_DINF_MIO_ROOT_OPTIMIZER_TIME" val="27">
   <cmnt>Time spent in the optimizer while solving the root node relaxation</cmnt>
  </c>
  <c name="MSK_DINF_TO_CONIC_TIME" val="89">
   <cmnt>Time spent in the last to conic reformulation.</cmnt>
  </c>
  <c name="MSK_DINF_MIO_CONSTRUCT_SOLUTION_OBJ" val="16">
   <cmnt>If |mosek| has successfully constructed an integer feasible solution, then this item contains the optimal objective value corresponding to the feasible solution.</cmnt>
  </c>
  <c name="MSK_DINF_MIO_OBJ_INT" val="23">
   <cmnt>The primal objective value corresponding to the best integer feasible solution. Please note that at least one integer feasible solution must have been located i.e. check :msk:const:`iinfitem.mio_num_int_solutions`.</cmnt>
  </c>
  <c name="MSK_DINF_MIO_OBJ_BOUND" val="22">
   <cmnt>The best known bound on the objective function. This value is undefined until at least
one relaxation has been solved: To see if this is the case check that :msk:const:`iinfitem.mio_num_relax` is
strictly positive.</cmnt>
  </c>
  <c name="MSK_DINF_MIO_OBJ_REL_GAP" val="24">
   <cmnt>Given that the mixed-integer optimizer has computed a feasible solution and a bound
on the optimal objective value, then this item contains the relative gap defined by

.. math:: \frac{| \mbox{(objective value of feasible solution)}-\mbox{(objective bound)} | }{\max(\delta,|\mbox{(objective value of feasible solution)}|)}.

where :math:`\delta` is given by the parameter :msk:dparam:`mio_rel_gap_const`. Otherwise it has the value :math:`-1.0`.</cmnt>
  </c>
  <c name="MSK_DINF_MIO_OBJ_ABS_GAP" val="21">
   <cmnt>Given the mixed-integer optimizer has computed a feasible solution and a bound on the optimal objective value, then this item contains the absolute gap defined by

.. math::  |\mbox{(objective value of feasible solution)}-\mbox{(objective bound)}|.

Otherwise it has the value -1.0.</cmnt>
  </c>
  <c name="MSK_DINF_MIO_USER_OBJ_CUT" val="30">
   <cmnt>If the objective cut is used, then this information item has the value of the cut.</cmnt>
  </c>
  <c name="MSK_DINF_MIO_CMIR_SEPARATION_TIME" val="15">
   <cmnt>Separation time for CMIR cuts.</cmnt>
  </c>
  <c name="MSK_DINF_MIO_CLIQUE_SEPARATION_TIME" val="14">
   <cmnt>Separation time for clique cuts.</cmnt>
  </c>
  <c name="MSK_DINF_MIO_KNAPSACK_COVER_SEPARATION_TIME" val="20">
   <cmnt>Separation time for knapsack cover.</cmnt>
  </c>
  <c name="MSK_DINF_MIO_GMI_SEPARATION_TIME" val="18">
   <cmnt>Separation time for GMI cuts.</cmnt>
  </c>
  <c name="MSK_DINF_MIO_IMPLIED_BOUND_TIME" val="19">
   <cmnt>Separation time for implied bound cuts.</cmnt>
  </c>
  <c name="MSK_DINF_MIO_ROOT_CUTGEN_TIME" val="26">
   <cmnt>Total time for cut generation.</cmnt>
  </c>
  <c name="MSK_DINF_MIO_PROBING_TIME" val="25">
   <cmnt>Total time for probing.</cmnt>
  </c>
  <c name="MSK_DINF_OPTIMIZER_TIME" val="31">
   <cmnt>Total time spent in the optimizer since it was invoked.</cmnt>
  </c>
  <c name="MSK_DINF_PRESOLVE_TIME" val="34">
   <cmnt>Total time (in seconds) spent in the presolve since it was invoked.</cmnt>
  </c>
  <c name="MSK_DINF_MIO_DUAL_BOUND_AFTER_PRESOLVE" val="17">
   <cmnt>Value of the dual bound after presolve but before cut generation.</cmnt>
  </c>
  <c name="MSK_DINF_PRESOLVE_ELI_TIME" val="32">
   <cmnt>Total time spent in the eliminator since the presolve was invoked.</cmnt>
  </c>
  <c name="MSK_DINF_PRESOLVE_LINDEP_TIME" val="33">
   <cmnt>Total time spent  in the linear dependency checker since the presolve was invoked.</cmnt>
  </c>
  <c name="MSK_DINF_RD_TIME" val="40">
   <cmnt>Time spent reading the data file.</cmnt>
  </c>
  <c name="MSK_DINF_SOL_ITR_PRIMAL_OBJ" val="84">
   <cmnt>Primal objective value of the interior-point solution.
Updated if :msk:iparam:`AUTO_UPDATE_SOL_INFO` is set MSK_ONLY[optimizer]|or by the method :msk:func:`task.updatesolutioninfo`|.</cmnt>
  </c>
  <c name="MSK_DINF_SOL_ITR_PVIOLCON" val="86">
   <cmnt>Maximal primal bound violation for :math:`x^c` in the interior-point solution.
Updated if :msk:iparam:`AUTO_UPDATE_SOL_INFO` is set MSK_ONLY[optimizer]|or by the method :msk:func:`task.updatesolutioninfo`|.</cmnt>
  </c>
  <c name="MSK_DINF_SOL_ITR_PVIOLVAR" val="88">
   <cmnt>Maximal primal bound violation for :math:`x^x` in the interior-point solution.
Updated if :msk:iparam:`AUTO_UPDATE_SOL_INFO` is set MSK_ONLY[optimizer]|or by the method :msk:func:`task.updatesolutioninfo`|.</cmnt>
  </c>
  <c name="MSK_DINF_SOL_ITR_PVIOLBARVAR" val="85">
   <cmnt>Maximal primal bound violation for :math:`\barX` in the interior-point solution.
Updated if :msk:iparam:`AUTO_UPDATE_SOL_INFO` is set MSK_ONLY[optimizer]|or by the method :msk:func:`task.updatesolutioninfo`|.</cmnt>
  </c>
  <c name="MSK_DINF_SOL_ITR_PVIOLCONES" val="87">
   <cmnt>Maximal primal violation for primal conic constraints in the interior-point solution.
Updated if :msk:iparam:`AUTO_UPDATE_SOL_INFO` is set MSK_ONLY[optimizer]|or by the method :msk:func:`task.updatesolutioninfo`|.</cmnt>
  </c>
  <c name="MSK_DINF_SOL_ITR_DUAL_OBJ" val="69">
   <cmnt>Dual objective value of the interior-point solution.
Updated if :msk:iparam:`AUTO_UPDATE_SOL_INFO` is set MSK_ONLY[optimizer]|or by the method :msk:func:`task.updatesolutioninfo`|.</cmnt>
  </c>
  <c name="MSK_DINF_SOL_ITR_DVIOLCON" val="71">
   <cmnt>Maximal dual bound violation for :math:`x^c` in the interior-point solution.
Updated if :msk:iparam:`AUTO_UPDATE_SOL_INFO` is set MSK_ONLY[optimizer]|or by the method :msk:func:`task.updatesolutioninfo`|.</cmnt>
  </c>
  <c name="MSK_DINF_SOL_ITR_DVIOLVAR" val="73">
   <cmnt>Maximal dual bound violation for :math:`x^x` in the interior-point solution.
Updated if :msk:iparam:`AUTO_UPDATE_SOL_INFO` is set MSK_ONLY[optimizer]|or by the method :msk:func:`task.updatesolutioninfo`|.</cmnt>
  </c>
  <c name="MSK_DINF_SOL_ITR_DVIOLBARVAR" val="70">
   <cmnt>Maximal dual bound violation for :math:`\barX` in the interior-point solution.
Updated if :msk:iparam:`AUTO_UPDATE_SOL_INFO` is set MSK_ONLY[optimizer]|or by the method :msk:func:`task.updatesolutioninfo`|.</cmnt>
  </c>
  <c name="MSK_DINF_SOL_ITR_DVIOLCONES" val="72">
   <cmnt>Maximal dual violation for dual conic constraints in the interior-point solution.
Updated if :msk:iparam:`AUTO_UPDATE_SOL_INFO` is set MSK_ONLY[optimizer]|or by the method :msk:func:`task.updatesolutioninfo`|.</cmnt>
  </c>
  <c name="MSK_DINF_SOL_ITR_NRM_XC" val="81">
   <cmnt>Infinity norm of :math:`x^c` in the interior-point solution.</cmnt>
  </c>
  <c name="MSK_DINF_SOL_ITR_NRM_XX" val="82">
   <cmnt>Infinity norm of :math:`x^x` in the interior-point solution.</cmnt>
  </c>
  <c name="MSK_DINF_SOL_ITR_NRM_BARX" val="75">
   <cmnt>Infinity norm of :math:`\barX` in the interior-point solution.</cmnt>
  </c>
  <c name="MSK_DINF_SOL_ITR_NRM_Y" val="83">
   <cmnt>Infinity norm of :math:`y` in the interior-point solution.</cmnt>
  </c>
  <c name="MSK_DINF_SOL_ITR_NRM_SLC" val="76">
   <cmnt>Infinity norm of :math:`s_l^c` in the interior-point solution.</cmnt>
  </c>
  <c name="MSK_DINF_SOL_ITR_NRM_SUC" val="79">
   <cmnt>Infinity norm of :math:`s_u^c` in the interior-point solution.</cmnt>
  </c>
  <c name="MSK_DINF_SOL_ITR_NRM_SLX" val="77">
   <cmnt>Infinity norm of :math:`s_l^x` in the interior-point solution.</cmnt>
  </c>
  <c name="MSK_DINF_SOL_ITR_NRM_SUX" val="80">
   <cmnt>Infinity norm of :math:`s_u^X` in the interior-point solution.</cmnt>
  </c>
  <c name="MSK_DINF_SOL_ITR_NRM_SNX" val="78">
   <cmnt>Infinity norm of :math:`s_n^x` in the interior-point solution.</cmnt>
  </c>
  <c name="MSK_DINF_SOL_ITR_NRM_BARS" val="74">
   <cmnt>Infinity norm of :math:`\barS` in the interior-point solution.</cmnt>
  </c>
  <c name="MSK_DINF_SOL_BAS_PRIMAL_OBJ" val="57">
   <cmnt>Primal objective value of the basic solution.
Updated if :msk:iparam:`AUTO_UPDATE_SOL_INFO` is set MSK_ONLY[optimizer]|or by the method :msk:func:`task.updatesolutioninfo`|.</cmnt>
  </c>
  <c name="MSK_DINF_SOL_BAS_PVIOLCON" val="58">
   <cmnt>Maximal primal bound violation for :math:`x^c` in the basic solution.
Updated if :msk:iparam:`AUTO_UPDATE_SOL_INFO` is set MSK_ONLY[optimizer]|or by the method :msk:func:`task.updatesolutioninfo`|.</cmnt>
  </c>
  <c name="MSK_DINF_SOL_BAS_PVIOLVAR" val="59">
   <cmnt>Maximal primal bound violation for :math:`x^x` in the basic solution.
Updated if :msk:iparam:`AUTO_UPDATE_SOL_INFO` is set MSK_ONLY[optimizer]|or by the method :msk:func:`task.updatesolutioninfo`|.</cmnt>
  </c>
  <c name="MSK_DINF_SOL_BAS_DUAL_OBJ" val="46">
   <cmnt>Dual objective value of the basic solution.
Updated if :msk:iparam:`AUTO_UPDATE_SOL_INFO` is set MSK_ONLY[optimizer]|or by the method :msk:func:`task.updatesolutioninfo`|.</cmnt>
  </c>
  <c name="MSK_DINF_SOL_BAS_DVIOLCON" val="47">
   <cmnt>Maximal dual bound violation for :math:`x^c` in the basic solution.
Updated if :msk:iparam:`AUTO_UPDATE_SOL_INFO` is set MSK_ONLY[optimizer]|or by the method :msk:func:`task.updatesolutioninfo`|.</cmnt>
  </c>
  <c name="MSK_DINF_SOL_BAS_DVIOLVAR" val="48">
   <cmnt>Maximal dual bound violation for :math:`x^x` in the basic solution.
Updated if :msk:iparam:`AUTO_UPDATE_SOL_INFO` is set MSK_ONLY[optimizer]|or by the method :msk:func:`task.updatesolutioninfo`|.</cmnt>
  </c>
  <c name="MSK_DINF_SOL_BAS_NRM_XC" val="54">
   <cmnt>Infinity norm of :math:`x^c` in the basic solution.</cmnt>
  </c>
  <c name="MSK_DINF_SOL_BAS_NRM_XX" val="55">
   <cmnt>Infinity norm of :math:`x^x` in the basic solution.</cmnt>
  </c>
  <c name="MSK_DINF_SOL_BAS_NRM_BARX" val="49">
   <cmnt>Infinity norm of :math:`\barX` in the basic solution.</cmnt>
  </c>
  <c name="MSK_DINF_SOL_BAS_NRM_Y" val="56">
   <cmnt>Infinity norm of :math:`y` in the basic solution.</cmnt>
  </c>
  <c name="MSK_DINF_SOL_BAS_NRM_SLC" val="50">
   <cmnt>Infinity norm of :math:`s_l^c` in the basic solution.</cmnt>
  </c>
  <c name="MSK_DINF_SOL_BAS_NRM_SUC" val="52">
   <cmnt>Infinity norm of :math:`s_u^c` in the basic solution.</cmnt>
  </c>
  <c name="MSK_DINF_SOL_BAS_NRM_SLX" val="51">
   <cmnt>Infinity norm of :math:`s_l^x` in the basic solution.</cmnt>
  </c>
  <c name="MSK_DINF_SOL_BAS_NRM_SUX" val="53">
   <cmnt>Infinity norm of :math:`s_u^X` in the basic solution.</cmnt>
  </c>
  <c name="MSK_DINF_SOL_ITG_PRIMAL_OBJ" val="63">
   <cmnt>Primal objective value of the integer solution.
Updated if :msk:iparam:`AUTO_UPDATE_SOL_INFO` is set MSK_ONLY[optimizer]|or by the method :msk:func:`task.updatesolutioninfo`|.</cmnt>
  </c>
  <c name="MSK_DINF_SOL_ITG_PVIOLCON" val="65">
   <cmnt>Maximal primal bound violation for :math:`x^c` in the integer solution.
Updated if :msk:iparam:`AUTO_UPDATE_SOL_INFO` is set MSK_ONLY[optimizer]|or by the method :msk:func:`task.updatesolutioninfo`|.</cmnt>
  </c>
  <c name="MSK_DINF_SOL_ITG_PVIOLVAR" val="68">
   <cmnt>Maximal primal bound violation for :math:`x^x` in the integer solution.
Updated if :msk:iparam:`AUTO_UPDATE_SOL_INFO` is set MSK_ONLY[optimizer]|or by the method :msk:func:`task.updatesolutioninfo`|.</cmnt>
  </c>
  <c name="MSK_DINF_SOL_ITG_PVIOLBARVAR" val="64">
   <cmnt>Maximal primal bound violation for :math:`\barX` in the integer solution.
Updated if :msk:iparam:`AUTO_UPDATE_SOL_INFO` is set MSK_ONLY[optimizer]|or by the method :msk:func:`task.updatesolutioninfo`|.</cmnt>
  </c>
  <c name="MSK_DINF_SOL_ITG_PVIOLCONES" val="66">
   <cmnt>Maximal primal violation for primal conic constraints in the integer solution.
Updated if :msk:iparam:`AUTO_UPDATE_SOL_INFO` is set MSK_ONLY[optimizer]|or by the method :msk:func:`task.updatesolutioninfo`|.</cmnt>
  </c>
  <c name="MSK_DINF_SOL_ITG_PVIOLITG" val="67">
   <cmnt>Maximal violation for the integer constraints in the integer solution.
Updated if :msk:iparam:`AUTO_UPDATE_SOL_INFO` is set MSK_ONLY[optimizer]|or by the method :msk:func:`task.updatesolutioninfo`|.</cmnt>
  </c>
  <c name="MSK_DINF_SOL_ITG_NRM_XC" val="61">
   <cmnt>Infinity norm of :math:`x^c` in the integer solution.</cmnt>
  </c>
  <c name="MSK_DINF_SOL_ITG_NRM_XX" val="62">
   <cmnt>Infinity norm of :math:`x^x` in the integer solution.</cmnt>
  </c>
  <c name="MSK_DINF_SOL_ITG_NRM_BARX" val="60">
   <cmnt>Infinity norm of :math:`\barX` in the integer solution.</cmnt>
  </c>
  <c name="MSK_DINF_INTPNT_FACTOR_NUM_FLOPS" val="8">
   <cmnt>An estimate of the number of flops used in the factorization.</cmnt>
  </c>
  <c name="MSK_DINF_QCQO_REFORMULATE_TIME" val="37">
   <cmnt>Time spent with conic quadratic reformulation.</cmnt>
  </c>
  <c name="MSK_DINF_QCQO_REFORMULATE_MAX_PERTURBATION" val="36">
   <cmnt>Maximum absolute diagonal perturbation occurring during the QCQO reformulation.</cmnt>
  </c>
  <c name="MSK_DINF_QCQO_REFORMULATE_WORST_CHOLESKY_DIAG_SCALING" val="39">
   <cmnt>Worst Cholesky diagonal scaling.</cmnt>
  </c>
  <c name="MSK_DINF_QCQO_REFORMULATE_WORST_CHOLESKY_COLUMN_SCALING" val="38">
   <cmnt>Worst Cholesky column scaling.</cmnt>
  </c>
  <c name="MSK_DINF_PRIMAL_REPAIR_PENALTY_OBJ" val="35">
   <cmnt>The optimal objective value of the penalty function.</cmnt>
  </c>
 </sec>
 <sec id="MSKfeaturee" type="enum">
  <cmnt>License feature</cmnt>
  <c name="MSK_FEATURE_PTS" val="0">
   <cmnt>Base system.</cmnt>
  </c>
  <c name="MSK_FEATURE_PTON" val="1">
   <cmnt>Conic extension.</cmnt>
  </c>
 </sec>
 <sec id="MSKdparame" type="parameters">
  <cmnt>The enumeration type containing all double parameters.</cmnt>
  <p name="MSK_DPAR_DATA_TOL_CJ_LARGE" val="13">
   <cmnt>An element in :math:`c` which is larger than this value in absolute terms causes a warning message to be printed.</cmnt>
   <lower_bound>0.0</lower_bound>
   <upper_bound>+inf</upper_bound>
   <default>1.0e8</default>
  </p>
  <p name="MSK_DPAR_DATA_TOL_C_HUGE" val="12">
   <cmnt>An element in :math:`c` which is larger than the value of this parameter in absolute terms is considered to be huge and generates an error.</cmnt>
   <lower_bound>0.0</lower_bound>
   <upper_bound>+inf</upper_bound>
   <default>1.0e16</default>
  </p>
  <p name="MSK_DPAR_DATA_TOL_AIJ_LARGE" val="9">
   <cmnt>An element in :math:`A` which is larger than this value in absolute size causes a warning message to be printed.</cmnt>
   <lower_bound>0.0</lower_bound>
   <upper_bound>+inf</upper_bound>
   <default>1.0e10</default>
  </p>
  <p name="MSK_DPAR_DATA_TOL_AIJ_HUGE" val="8">
   <cmnt>An element in :math:`A` which is larger than this value in absolute size causes an error.</cmnt>
   <lower_bound>0.0</lower_bound>
   <upper_bound>+inf</upper_bound>
   <default>1.0e20</default>
  </p>
  <p name="MSK_DPAR_DATA_SYM_MAT_TOL" val="5">
   <cmnt>Absolute zero tolerance for elements in in symmetric matrices. If any value in a symmetric matrix is smaller than this parameter in absolute terms |mosek| will treat the values as zero and generate a warning.</cmnt>
   <lower_bound>1.0e-16</lower_bound>
   <upper_bound>1.0e-6</upper_bound>
   <default>1.0e-12</default>
  </p>
  <p name="MSK_DPAR_DATA_SYM_MAT_TOL_LARGE" val="7">
   <cmnt>An element in a symmetric matrix which is larger than this value in absolute size causes a warning message to be printed.</cmnt>
   <lower_bound>0.0</lower_bound>
   <upper_bound>+inf</upper_bound>
   <default>1.0e10</default>
  </p>
  <p name="MSK_DPAR_DATA_SYM_MAT_TOL_HUGE" val="6">
   <cmnt>An element in a symmetric matrix which is larger than this value in absolute size causes an error.</cmnt>
   <lower_bound>0.0</lower_bound>
   <upper_bound>+inf</upper_bound>
   <default>1.0e20</default>
  </p>
  <p name="MSK_DPAR_DATA_TOL_BOUND_INF" val="10">
   <cmnt>Any bound which in absolute value
is greater than this parameter is
considered infinite.</cmnt>
   <lower_bound>0.0</lower_bound>
   <upper_bound>+inf</upper_bound>
   <default>1.0e16</default>
  </p>
  <p name="MSK_DPAR_DATA_TOL_BOUND_WRN" val="11">
   <cmnt>If a bound value is larger than this value
in absolute size, then a warning message is issued.</cmnt>
   <lower_bound>0.0</lower_bound>
   <upper_bound>+inf</upper_bound>
   <default>1.0e8</default>
  </p>
  <p name="MSK_DPAR_DATA_TOL_QIJ" val="14">
   <cmnt>Absolute zero tolerance for elements in :math:`Q` matrices.</cmnt>
   <lower_bound>0.0</lower_bound>
   <upper_bound>+inf</upper_bound>
   <default>1.0e-16</default>
  </p>
  <p name="MSK_DPAR_DATA_TOL_X" val="15">
   <cmnt>Zero tolerance for constraints and variables i.e.
if the distance between the lower and upper bound
is less than this value, then the lower and upper
bound is considered identical.</cmnt>
   <lower_bound>0.0</lower_bound>
   <upper_bound>+inf</upper_bound>
   <default>1.0e-8</default>
  </p>
  <p name="MSK_DPAR_SEMIDEFINITE_TOL_APPROX" val="54">
   <cmnt>Tolerance to define a matrix to be positive semidefinite.</cmnt>
   <lower_bound>1.0e-15</lower_bound>
   <upper_bound>+inf</upper_bound>
   <default>1.0e-10</default>
  </p>
  <p name="MSK_DPAR_OPTIMIZER_MAX_TIME" val="47">
   <cmnt>Maximum amount of time the optimizer is allowed to spent on the optimization.
A negative number means infinity.</cmnt>
   <lower_bound>-inf</lower_bound>
   <upper_bound>+inf</upper_bound>
   <default>-1.0</default>
  </p>
  <p name="MSK_DPAR_LOWER_OBJ_CUT" val="38">
   <cmnt>If either a primal or dual feasible solution is found proving that the optimal objective value is outside the interval :math:`[` :msk:dparam:`lower_obj_cut`, :msk:dparam:`upper_obj_cut` :math:`]`, then |mosek| is terminated.</cmnt>
   <lower_bound>-inf</lower_bound>
   <upper_bound>+inf</upper_bound>
   <default>-1.0e30</default>
   <seealso key="MSK_DPAR_LOWER_OBJ_CUT_FINITE_TRH"/>
  </p>
  <p name="MSK_DPAR_UPPER_OBJ_CUT" val="57">
   <cmnt>If either a primal or dual feasible solution is found proving that the optimal objective value is outside the interval :math:`[` :msk:dparam:`lower_obj_cut`, :msk:dparam:`upper_obj_cut` :math:`]`, then |mosek| is terminated.</cmnt>
   <lower_bound>-inf</lower_bound>
   <upper_bound>+inf</upper_bound>
   <default>1.0e30</default>
   <seealso key="MSK_DPAR_UPPER_OBJ_CUT_FINITE_TRH"/>
  </p>
  <p name="MSK_DPAR_UPPER_OBJ_CUT_FINITE_TRH" val="58">
   <cmnt>If the upper objective cut is greater than the value of this parameter, then the
upper objective cut :msk:dparam:`upper_obj_cut` is treated as :math:`\infty`.</cmnt>
   <lower_bound>-inf</lower_bound>
   <upper_bound>+inf</upper_bound>
   <default>0.5e30</default>
  </p>
  <p name="MSK_DPAR_LOWER_OBJ_CUT_FINITE_TRH" val="39">
   <cmnt>If the lower objective cut is less than the value of this parameter value, then the lower objective cut i.e. :msk:dparam:`lower_obj_cut`  is treated as :math:`-\infty`.</cmnt>
   <lower_bound>-inf</lower_bound>
   <upper_bound>+inf</upper_bound>
   <default>-0.5e30</default>
  </p>
  <p name="MSK_DPAR_INTPNT_TOL_REL_GAP" val="35">
   <cmnt>Relative gap termination tolerance used by the interior-point optimizer for linear problems.</cmnt>
   <lower_bound>1.0e-14</lower_bound>
   <upper_bound>+inf</upper_bound>
   <default>1.0e-8</default>
  </p>
  <p name="MSK_DPAR_INTPNT_TOL_STEP_SIZE" val="37">
   <cmnt>Minimal step size tolerance. If the step size falls below the value of this parameter, then the interior-point optimizer assumes that it is stalled. In other words the interior-point optimizer does not make any progress and therefore it is better to stop.</cmnt>
   <lower_bound>0.0</lower_bound>
   <upper_bound>1.0</upper_bound>
   <default>1.0e-6</default>
  </p>
  <p name="MSK_DPAR_SIM_LU_TOL_REL_PIV" val="55">
   <cmnt>Relative pivot tolerance employed when computing the LU factorization
of the basis in the simplex optimizers and in the basis identification procedure.
A value closer to 1.0 generally improves numerical stability but typically also implies an
increase in the computational work.</cmnt>
   <lower_bound>1.0e-6</lower_bound>
   <upper_bound>0.999999</upper_bound>
   <default>0.01</default>
  </p>
  <p name="MSK_DPAR_INTPNT_TOL_REL_STEP" val="36">
   <cmnt>Relative step size to the boundary for linear and quadratic optimization problems.</cmnt>
   <lower_bound>1.0e-4</lower_bound>
   <upper_bound>0.999999</upper_bound>
   <default>0.9999</default>
  </p>
  <p name="MSK_DPAR_INTPNT_TOL_PATH" val="32">
   <cmnt>Controls how close
the interior-point optimizer follows the central path. A large
value of this parameter means the central path is
followed very closely. On numerically unstable
problems it may be worthwhile to increase this
parameter.</cmnt>
   <lower_bound>0.0</lower_bound>
   <upper_bound>0.9999</upper_bound>
   <default>1.0e-8</default>
  </p>
  <p name="MSK_DPAR_INTPNT_TOL_PFEAS" val="33">
   <cmnt>Primal feasibility tolerance used by the interior-point optimizer for linear problems.</cmnt>
   <lower_bound>0.0</lower_bound>
   <upper_bound>1.0</upper_bound>
   <default>1.0e-8</default>
  </p>
  <p name="MSK_DPAR_INTPNT_TOL_DFEAS" val="28">
   <cmnt>Dual feasibility tolerance used by the interior-point optimizer for linear problems.</cmnt>
   <lower_bound>0.0</lower_bound>
   <upper_bound>1.0</upper_bound>
   <default>1.0e-8</default>
  </p>
  <p name="MSK_DPAR_INTPNT_TOL_MU_RED" val="31">
   <cmnt>Relative complementarity gap tolerance used by the interior-point optimizer for linear problems.</cmnt>
   <lower_bound>0.0</lower_bound>
   <upper_bound>1.0</upper_bound>
   <default>1.0e-16</default>
  </p>
  <p name="MSK_DPAR_INTPNT_TOL_INFEAS" val="30">
   <cmnt>Infeasibility tolerance used by the interior-point optimizer for linear problems.
Controls when the interior-point optimizer declares
the model primal or dual infeasible. A small number means the optimizer
gets more conservative about declaring the model infeasible.</cmnt>
   <lower_bound>0.0</lower_bound>
   <upper_bound>1.0</upper_bound>
   <default>1.0e-10</default>
  </p>
  <p name="MSK_DPAR_INTPNT_CO_TOL_REL_GAP" val="21">
   <cmnt>Relative gap termination tolerance used by the interior-point optimizer for conic problems.</cmnt>
   <lower_bound>0.0</lower_bound>
   <upper_bound>1.0</upper_bound>
   <default>1.0e-8</default>
   <seealso key="MSK_DPAR_INTPNT_CO_TOL_NEAR_REL"/>
  </p>
  <p name="MSK_DPAR_INTPNT_CO_TOL_PFEAS" val="20">
   <cmnt>Primal feasibility tolerance used by the interior-point optimizer for conic problems.</cmnt>
   <lower_bound>0.0</lower_bound>
   <upper_bound>1.0</upper_bound>
   <default>1.0e-8</default>
   <seealso key="MSK_DPAR_INTPNT_CO_TOL_NEAR_REL"/>
  </p>
  <p name="MSK_DPAR_INTPNT_CO_TOL_DFEAS" val="16">
   <cmnt>Dual feasibility tolerance used by the interior-point optimizer for conic problems.</cmnt>
   <lower_bound>0.0</lower_bound>
   <upper_bound>1.0</upper_bound>
   <default>1.0e-8</default>
   <seealso key="MSK_DPAR_INTPNT_CO_TOL_NEAR_REL"/>
  </p>
  <p name="MSK_DPAR_INTPNT_CO_TOL_MU_RED" val="18">
   <cmnt>Relative complementarity gap tolerance used by the interior-point optimizer for conic problems.</cmnt>
   <lower_bound>0.0</lower_bound>
   <upper_bound>1.0</upper_bound>
   <default>1.0e-8</default>
  </p>
  <p name="MSK_DPAR_INTPNT_CO_TOL_NEAR_REL" val="19">
   <cmnt>Optimality tolerance used by the interior-point optimizer for conic problems.
If |mosek| cannot compute a solution that has the prescribed accuracy then
it will check if the solution found satisfies the termination criteria with all tolerances
multiplied by the value of this parameter. If yes, then the solution is also declared optimal.</cmnt>
   <lower_bound>1.0</lower_bound>
   <upper_bound>+inf</upper_bound>
   <default>1000</default>
  </p>
  <p name="MSK_DPAR_INTPNT_CO_TOL_INFEAS" val="17">
   <cmnt>Infeasibility tolerance used by the interior-point optimizer for conic problems.
Controls when the interior-point optimizer declares
the model primal or dual infeasible. A small number means the optimizer
gets more conservative about declaring the model infeasible.</cmnt>
   <lower_bound>0.0</lower_bound>
   <upper_bound>1.0</upper_bound>
   <default>1.0e-12</default>
  </p>
  <p name="MSK_DPAR_INTPNT_QO_TOL_REL_GAP" val="27">
   <cmnt>Relative gap termination tolerance used by the interior-point optimizer for quadratic problems.</cmnt>
   <lower_bound>0.0</lower_bound>
   <upper_bound>1.0</upper_bound>
   <default>1.0e-8</default>
   <seealso key="MSK_DPAR_INTPNT_QO_TOL_NEAR_REL"/>
  </p>
  <p name="MSK_DPAR_INTPNT_QO_TOL_PFEAS" val="26">
   <cmnt>Primal feasibility tolerance used by the interior-point optimizer for quadratic problems.</cmnt>
   <lower_bound>0.0</lower_bound>
   <upper_bound>1.0</upper_bound>
   <default>1.0e-8</default>
   <seealso key="MSK_DPAR_INTPNT_QO_TOL_NEAR_REL"/>
  </p>
  <p name="MSK_DPAR_INTPNT_QO_TOL_DFEAS" val="22">
   <cmnt>Dual feasibility tolerance used by the interior-point optimizer for quadratic problems.</cmnt>
   <lower_bound>0.0</lower_bound>
   <upper_bound>1.0</upper_bound>
   <default>1.0e-8</default>
   <seealso key="MSK_DPAR_INTPNT_QO_TOL_NEAR_REL"/>
  </p>
  <p name="MSK_DPAR_INTPNT_QO_TOL_MU_RED" val="24">
   <cmnt>Relative complementarity gap tolerance used by the interior-point optimizer for quadratic problems.</cmnt>
   <lower_bound>0.0</lower_bound>
   <upper_bound>1.0</upper_bound>
   <default>1.0e-8</default>
  </p>
  <p name="MSK_DPAR_INTPNT_QO_TOL_NEAR_REL" val="25">
   <cmnt>Optimality tolerance used by the interior-point optimizer for quadratic problems.
If |mosek| cannot compute a solution that has the prescribed accuracy then
it will check if the solution found satisfies the termination criteria with all tolerances
multiplied by the value of this parameter. If yes, then the solution is also declared optimal.</cmnt>
   <lower_bound>1.0</lower_bound>
   <upper_bound>+inf</upper_bound>
   <default>1000</default>
  </p>
  <p name="MSK_DPAR_INTPNT_QO_TOL_INFEAS" val="23">
   <cmnt>Infeasibility tolerance used by the interior-point optimizer for quadratic problems.
Controls when the interior-point optimizer declares
the model primal or dual infeasible. A small number means the optimizer
gets more conservative about declaring the model infeasible.</cmnt>
   <lower_bound>0.0</lower_bound>
   <upper_bound>1.0</upper_bound>
   <default>1.0e-12</default>
  </p>
  <p name="MSK_DPAR_INTPNT_TOL_PSAFE" val="34">
   <cmnt>Controls the initial primal starting point used by
the interior-point optimizer. If the interior-point optimizer
converges slowly and/or the constraint or variable bounds are very
large, then it may be worthwhile to increase this value.</cmnt>
   <lower_bound>1.0e-4</lower_bound>
   <upper_bound>+inf</upper_bound>
   <default>1.0</default>
  </p>
  <p name="MSK_DPAR_INTPNT_TOL_DSAFE" val="29">
   <cmnt>Controls the initial dual starting point used by
the interior-point optimizer. If the interior-point optimizer
converges slowly and/or the constraint or variable bounds are very large,
then it might be worthwhile to increase this value.</cmnt>
   <lower_bound>1.0e-4</lower_bound>
   <upper_bound>+inf</upper_bound>
   <default>1.0</default>
  </p>
  <p name="MSK_DPAR_MIO_MAX_TIME" val="40">
   <cmnt>This parameter limits the maximum time spent by the mixed-integer optimizer.
A negative number means infinity.</cmnt>
   <lower_bound>-inf</lower_bound>
   <upper_bound>+inf</upper_bound>
   <default>-1.0</default>
  </p>
  <p name="MSK_DPAR_MIO_REL_GAP_CONST" val="41">
   <cmnt>This value is used to compute the relative gap for the solution to an integer optimization problem.</cmnt>
   <lower_bound>1.0e-15</lower_bound>
   <upper_bound>+inf</upper_bound>
   <default>1.0e-10</default>
  </p>
  <p name="MSK_DPAR_MIO_TOL_REL_GAP" val="46">
   <cmnt>Relative optimality tolerance employed by the mixed-integer optimizer.</cmnt>
   <lower_bound>0.0</lower_bound>
   <upper_bound>+inf</upper_bound>
   <default>1.0e-4</default>
  </p>
  <p name="MSK_DPAR_MIO_TOL_ABS_GAP" val="42">
   <cmnt>Absolute optimality tolerance employed by the mixed-integer optimizer.</cmnt>
   <lower_bound>0.0</lower_bound>
   <upper_bound>+inf</upper_bound>
   <default>0.0</default>
  </p>
  <p name="MSK_DPAR_MIO_TOL_ABS_RELAX_INT" val="43">
   <cmnt>Absolute integer feasibility tolerance. If the distance to the nearest integer is less than this tolerance
then an integer constraint is assumed to be satisfied.</cmnt>
   <lower_bound>1e-9</lower_bound>
   <upper_bound>+inf</upper_bound>
   <default>1.0e-5</default>
  </p>
  <p name="MSK_DPAR_BASIS_TOL_X" val="3">
   <cmnt>Maximum absolute primal bound violation allowed in an optimal basic solution.</cmnt>
   <lower_bound>1.0e-9</lower_bound>
   <upper_bound>+inf</upper_bound>
   <default>1.0e-6</default>
  </p>
  <p name="MSK_DPAR_BASIS_TOL_S" val="2">
   <cmnt>Maximum absolute dual bound violation in an optimal basic solution.</cmnt>
   <lower_bound>1.0e-9</lower_bound>
   <upper_bound>+inf</upper_bound>
   <default>1.0e-6</default>
  </p>
  <p name="MSK_DPAR_BASIS_REL_TOL_S" val="1">
   <cmnt>Maximum relative dual bound violation allowed in an optimal basic solution.</cmnt>
   <lower_bound>0.0</lower_bound>
   <upper_bound>+inf</upper_bound>
   <default>1.0e-12</default>
  </p>
  <p name="MSK_DPAR_PRESOLVE_TOL_X" val="52">
   <cmnt>Absolute zero tolerance employed for :math:`x_j` in the presolve.</cmnt>
   <lower_bound>0.0</lower_bound>
   <upper_bound>+inf</upper_bound>
   <default>1.0e-8</default>
  </p>
  <p name="MSK_DPAR_PRESOLVE_TOL_S" val="51">
   <cmnt>Absolute zero tolerance employed for :math:`s_i` in the presolve.</cmnt>
   <lower_bound>0.0</lower_bound>
   <upper_bound>+inf</upper_bound>
   <default>1.0e-8</default>
  </p>
  <p name="MSK_DPAR_PRESOLVE_TOL_AIJ" val="49">
   <cmnt>Absolute zero tolerance employed for :math:`a_{ij}` in the presolve.</cmnt>
   <lower_bound>1.0e-15</lower_bound>
   <upper_bound>+inf</upper_bound>
   <default>1.0e-12</default>
  </p>
  <p name="MSK_DPAR_PRESOLVE_TOL_ABS_LINDEP" val="48">
   <cmnt>Absolute tolerance employed by the linear dependency checker.</cmnt>
   <lower_bound>0.0</lower_bound>
   <upper_bound>+inf</upper_bound>
   <default>1.0e-6</default>
  </p>
  <p name="MSK_DPAR_PRESOLVE_TOL_REL_LINDEP" val="50">
   <cmnt>Relative tolerance employed by the linear dependency checker.</cmnt>
   <lower_bound>0.0</lower_bound>
   <upper_bound>+inf</upper_bound>
   <default>1.0e-10</default>
  </p>
  <p name="MSK_DPAR_SIMPLEX_ABS_TOL_PIV" val="56">
   <cmnt>Absolute pivot tolerance employed by the simplex optimizers.</cmnt>
   <lower_bound>1.0e-12</lower_bound>
   <upper_bound>+inf</upper_bound>
   <default>1.0e-7</default>
  </p>
  <p name="MSK_DPAR_MIO_TOL_FEAS" val="44">
   <cmnt>Feasibility tolerance for mixed integer solver.</cmnt>
   <lower_bound>1e-9</lower_bound>
   <upper_bound>1e-3</upper_bound>
   <default>1.0e-6</default>
  </p>
  <p name="MSK_DPAR_ANA_SOL_INFEAS_TOL" val="0">
   <cmnt>If a constraint violates its bound with an amount larger than this value, the constraint name, index and violation will be printed by the solution analyzer.</cmnt>
   <lower_bound>0.0</lower_bound>
   <upper_bound>+inf</upper_bound>
   <default>1e-6</default>
  </p>
  <p name="MSK_DPAR_CHECK_CONVEXITY_REL_TOL" val="4">
   <cmnt>This parameter controls when the full convexity check declares a problem to be non-convex.
Increasing this tolerance relaxes the criteria for declaring the problem non-convex.

A problem is declared non-convex if negative (positive) pivot elements are detected in the Cholesky factor of a matrix
which is required to be PSD (NSD). This parameter controls how much this non-negativity requirement may be violated.

If :math:`d_i` is the pivot element for column :math:`i`, then the matrix :math:`Q` is considered to not be PSD if:

.. math::  d_i \leq - |Q_{ii}|  \mathtt{check\_convexity\_rel\_tol}</cmnt>
   <lower_bound>0</lower_bound>
   <upper_bound>+inf</upper_bound>
   <default>1e-10</default>
  </p>
  <p name="MSK_DPAR_QCQO_REFORMULATE_REL_DROP_TOL" val="53">
   <cmnt>This parameter determines when columns are dropped in incomplete Cholesky factorization during reformulation of quadratic problems.</cmnt>
   <lower_bound>0</lower_bound>
   <upper_bound>+inf</upper_bound>
   <default>1e-15</default>
  </p>
  <p name="MSK_DPAR_MIO_TOL_REL_DUAL_BOUND_IMPROVEMENT" val="45">
   <cmnt>If the relative improvement of the dual bound is smaller than this value, the solver will terminate the root cut generation.
A value of 0.0 means that the value is selected automatically.</cmnt>
   <lower_bound>0.0</lower_bound>
   <upper_bound>1.0</upper_bound>
   <default>0.0</default>
  </p>
 </sec>
 <sec id="MSKliinfiteme" type="enum">
  <cmnt>Long integer information items.</cmnt>
  <c name="MSK_LIINF_MIO_ANZ" val="7">
   <cmnt>Number of non-zero entries in the constraint matrix of the probelm to be solved by the mixed-integer optimizer.</cmnt>
  </c>
  <c name="MSK_LIINF_MIO_PRESOLVED_ANZ" val="9">
   <cmnt>Number of non-zero entries in the constraint matrix of the problem after the mixed-integer optimizer's presolve.</cmnt>
  </c>
  <c name="MSK_LIINF_MIO_SIMPLEX_ITER" val="10">
   <cmnt>Number of simplex iterations performed by the mixed-integer optimizer.</cmnt>
  </c>
  <c name="MSK_LIINF_MIO_INTPNT_ITER" val="8">
   <cmnt>Number of interior-point iterations performed by the mixed-integer optimizer.</cmnt>
  </c>
  <c name="MSK_LIINF_BI_PRIMAL_ITER" val="5">
   <cmnt>Number of primal pivots performed in the basis identification.</cmnt>
  </c>
  <c name="MSK_LIINF_BI_DUAL_ITER" val="4">
   <cmnt>Number of dual pivots performed in the basis identification.</cmnt>
  </c>
  <c name="MSK_LIINF_BI_CLEAN_PRIMAL_ITER" val="3">
   <cmnt>Number of primal clean iterations performed in the basis identification.</cmnt>
  </c>
  <c name="MSK_LIINF_BI_CLEAN_DUAL_ITER" val="1">
   <cmnt>Number of dual clean iterations performed in the basis identification.</cmnt>
  </c>
  <c name="MSK_LIINF_BI_CLEAN_PRIMAL_DEG_ITER" val="2">
   <cmnt>Number of primal degenerate clean iterations performed in the basis identification.</cmnt>
  </c>
  <c name="MSK_LIINF_BI_CLEAN_DUAL_DEG_ITER" val="0">
   <cmnt>Number of dual degenerate clean iterations performed in the basis identification.</cmnt>
  </c>
  <c name="MSK_LIINF_INTPNT_FACTOR_NUM_NZ" val="6">
   <cmnt>Number of non-zeros in factorization.</cmnt>
  </c>
  <c name="MSK_LIINF_RD_NUMANZ" val="11">
   <cmnt>Number of non-zeros in A that is read.</cmnt>
  </c>
  <c name="MSK_LIINF_RD_NUMQNZ" val="12">
   <cmnt>Number of Q non-zeros.</cmnt>
  </c>
 </sec>
 <sec id="MSKiinfiteme" type="enum">
  <cmnt>Integer information items.</cmnt>
  <c name="MSK_IINF_ANA_PRO_NUM_CON" val="0">
   <cmnt>Number of constraints in the problem. MSK_ONLY[optimizer]|This value is set by :msk:func:`task.analyzeproblem`.|</cmnt>
  </c>
  <c name="MSK_IINF_ANA_PRO_NUM_CON_LO" val="3">
   <cmnt>Number of constraints with a lower bound and an infinite upper bound. MSK_ONLY[optimizer]|This value is set by :msk:func:`task.analyzeproblem`.|</cmnt>
  </c>
  <c name="MSK_IINF_ANA_PRO_NUM_CON_UP" val="5">
   <cmnt>Number of constraints with an upper bound and an infinite lower bound. MSK_ONLY[optimizer]|This value is set by :msk:func:`task.analyzeproblem`.|</cmnt>
  </c>
  <c name="MSK_IINF_ANA_PRO_NUM_CON_RA" val="4">
   <cmnt>Number of constraints with finite lower and upper bounds. MSK_ONLY[optimizer]|This value is set by :msk:func:`task.analyzeproblem`.|</cmnt>
  </c>
  <c name="MSK_IINF_ANA_PRO_NUM_CON_EQ" val="1">
   <cmnt>Number of equality constraints. MSK_ONLY[optimizer]|This value is set by :msk:func:`task.analyzeproblem`.|</cmnt>
  </c>
  <c name="MSK_IINF_ANA_PRO_NUM_CON_FR" val="2">
   <cmnt>Number of unbounded constraints. MSK_ONLY[optimizer]|This value is set by :msk:func:`task.analyzeproblem`.|</cmnt>
  </c>
  <c name="MSK_IINF_ANA_PRO_NUM_VAR" val="6">
   <cmnt>Number of variables in the problem. MSK_ONLY[optimizer]|This value is set by :msk:func:`task.analyzeproblem`.|</cmnt>
  </c>
  <c name="MSK_IINF_ANA_PRO_NUM_VAR_LO" val="12">
   <cmnt>Number of variables with a lower bound and an infinite upper bound. MSK_ONLY[optimizer]|This value is set by :msk:func:`task.analyzeproblem`.|</cmnt>
  </c>
  <c name="MSK_IINF_ANA_PRO_NUM_VAR_UP" val="14">
   <cmnt>Number of variables with an upper bound and an infinite lower bound. MSK_ONLY[optimizer]|This value is set by :msk:func:`task.analyzeproblem`.|</cmnt>
  </c>
  <c name="MSK_IINF_ANA_PRO_NUM_VAR_RA" val="13">
   <cmnt>Number of variables with finite lower and upper bounds. MSK_ONLY[optimizer]|This value is set by :msk:func:`task.analyzeproblem`.|</cmnt>
  </c>
  <c name="MSK_IINF_ANA_PRO_NUM_VAR_EQ" val="9">
   <cmnt>Number of fixed variables. MSK_ONLY[optimizer]|This value is set by :msk:func:`task.analyzeproblem`.|</cmnt>
  </c>
  <c name="MSK_IINF_ANA_PRO_NUM_VAR_FR" val="10">
   <cmnt>Number of free variables. MSK_ONLY[optimizer]|This value is set by :msk:func:`task.analyzeproblem`.|</cmnt>
  </c>
  <c name="MSK_IINF_ANA_PRO_NUM_VAR_CONT" val="8">
   <cmnt>Number of continuous variables. MSK_ONLY[optimizer]|This value is set by :msk:func:`task.analyzeproblem`.|</cmnt>
  </c>
  <c name="MSK_IINF_ANA_PRO_NUM_VAR_BIN" val="7">
   <cmnt>Number of binary (0-1) variables. MSK_ONLY[optimizer]|This value is set by :msk:func:`task.analyzeproblem`.|</cmnt>
  </c>
  <c name="MSK_IINF_ANA_PRO_NUM_VAR_INT" val="11">
   <cmnt>Number of general integer variables. MSK_ONLY[optimizer]|This value is set by :msk:func:`task.analyzeproblem`.|</cmnt>
  </c>
  <c name="MSK_IINF_OPTIMIZE_RESPONSE" val="71">
   <cmnt>The response code returned by optimize.</cmnt>
  </c>
  <c name="MSK_IINF_INTPNT_ITER" val="16">
   <cmnt>Number of interior-point iterations since invoking the interior-point optimizer.</cmnt>
  </c>
  <c name="MSK_IINF_INTPNT_FACTOR_DIM_DENSE" val="15">
   <cmnt>Dimension of the dense sub system in factorization.</cmnt>
  </c>
  <c name="MSK_IINF_INTPNT_SOLVE_DUAL" val="18">
   <cmnt>Non-zero if the interior-point optimizer is solving the dual problem.</cmnt>
  </c>
  <c name="MSK_IINF_MIO_NODE_DEPTH" val="22">
   <cmnt>Depth of the last node solved.</cmnt>
  </c>
  <c name="MSK_IINF_MIO_NUMVAR" val="48">
   <cmnt>Number of variables in the problem to be solved by the mixed-integer optimizer.</cmnt>
  </c>
  <c name="MSK_IINF_MIO_NUMBIN" val="33">
   <cmnt>Number of binary variables in the problem to be solved by the mixed-integer optimizer.</cmnt>
  </c>
  <c name="MSK_IINF_MIO_NUMINT" val="42">
   <cmnt>Number of integer variables in the problem to be solved by the mixed-integer optimizer.</cmnt>
  </c>
  <c name="MSK_IINF_MIO_NUMCONT" val="38">
   <cmnt>Number of continuous variables in the problem to be solved by the mixed-integer optimizer.</cmnt>
  </c>
  <c name="MSK_IINF_MIO_NUMCON" val="35">
   <cmnt>Number of constraints in the problem to be solved by the mixed-integer optimizer.</cmnt>
  </c>
  <c name="MSK_IINF_MIO_NUMCONE" val="36">
   <cmnt>Number of cones in the problem to be solved by the mixed-integer optimizer.</cmnt>
  </c>
  <c name="MSK_IINF_MIO_NUMQCONES" val="46">
   <cmnt>Number of quadratic cones in the problem to be solved by the mixed-integer optimizer.</cmnt>
  </c>
  <c name="MSK_IINF_MIO_NUMRQCONES" val="47">
   <cmnt>Number of rotated quadratic cones in the problem to be solved by the mixed-integer optimizer.</cmnt>
  </c>
  <c name="MSK_IINF_MIO_NUMPEXPCONES" val="44">
   <cmnt>Number of primal exponential cones in the problem to be solved by the mixed-integer optimizer.</cmnt>
  </c>
  <c name="MSK_IINF_MIO_NUMDEXPCONES" val="40">
   <cmnt>Number of dual exponential cones in the problem to be solved by the mixed-integer optimizer.</cmnt>
  </c>
  <c name="MSK_IINF_MIO_NUMPPOWCONES" val="45">
   <cmnt>Number of primal power cones in the problem to be solved by the mixed-integer optimizer.</cmnt>
  </c>
  <c name="MSK_IINF_MIO_NUMDPOWCONES" val="41">
   <cmnt>Number of dual power cones in the problem to be solved by the mixed-integer optimizer.</cmnt>
  </c>
  <c name="MSK_IINF_MIO_NUMCONEVAR" val="37">
   <cmnt>Number of cone variables in the problem to be solved by the mixed-integer optimizer.</cmnt>
  </c>
  <c name="MSK_IINF_MIO_NUMBINCONEVAR" val="34">
   <cmnt>Number of binary cone variables in the problem to be solved by the mixed-integer optimizer.</cmnt>
  </c>
  <c name="MSK_IINF_MIO_NUMINTCONEVAR" val="43">
   <cmnt>Number of integer cone variables in the problem to be solved by the mixed-integer optimizer.</cmnt>
  </c>
  <c name="MSK_IINF_MIO_NUMCONTCONEVAR" val="39">
   <cmnt>Number of continuous cone variables in the problem to be solved by the mixed-integer optimizer.</cmnt>
  </c>
  <c name="MSK_IINF_MIO_PRESOLVED_NUMVAR" val="65">
   <cmnt>Number of variables in the problem after the mixed-integer optimizer's presolve.</cmnt>
  </c>
  <c name="MSK_IINF_MIO_PRESOLVED_NUMBIN" val="50">
   <cmnt>Number of binary variables in the problem after the mixed-integer optimizer's presolve.</cmnt>
  </c>
  <c name="MSK_IINF_MIO_PRESOLVED_NUMINT" val="59">
   <cmnt>Number of integer variables in the problem after the mixed-integer optimizer's presolve.</cmnt>
  </c>
  <c name="MSK_IINF_MIO_PRESOLVED_NUMCONT" val="55">
   <cmnt>Number of continuous variables in the problem after the mixed-integer optimizer's presolve.</cmnt>
  </c>
  <c name="MSK_IINF_MIO_PRESOLVED_NUMCON" val="52">
   <cmnt>Number of constraints in the problem after the mixed-integer optimizer's presolve.</cmnt>
  </c>
  <c name="MSK_IINF_MIO_PRESOLVED_NUMCONE" val="53">
   <cmnt>Number of cones in the problem after the mixed-integer optimizer's presolve.</cmnt>
  </c>
  <c name="MSK_IINF_MIO_PRESOLVED_NUMQCONES" val="63">
   <cmnt>Number of quadratic cones in the problem after the mixed-integer optimizer's presolve.</cmnt>
  </c>
  <c name="MSK_IINF_MIO_PRESOLVED_NUMRQCONES" val="64">
   <cmnt>Number of rotated quadratic cones in the problem after the mixed-integer optimizer's presolve.</cmnt>
  </c>
  <c name="MSK_IINF_MIO_PRESOLVED_NUMPEXPCONES" val="61">
   <cmnt>Number of primal exponential cones in the problem after the mixed-integer optimizer's presolve.</cmnt>
  </c>
  <c name="MSK_IINF_MIO_PRESOLVED_NUMDEXPCONES" val="57">
   <cmnt>Number of dual exponential cones in the problem after the mixed-integer optimizer's presolve.</cmnt>
  </c>
  <c name="MSK_IINF_MIO_PRESOLVED_NUMPPOWCONES" val="62">
   <cmnt>Number of primal power cones in the problem after the mixed-integer optimizer's presolve.</cmnt>
  </c>
  <c name="MSK_IINF_MIO_PRESOLVED_NUMDPOWCONES" val="58">
   <cmnt>Number of dual power cones in the problem after the mixed-integer optimizer's presolve.</cmnt>
  </c>
  <c name="MSK_IINF_MIO_PRESOLVED_NUMCONEVAR" val="54">
   <cmnt>Number of cone variables in the problem after the mixed-integer optimizer's presolve.</cmnt>
  </c>
  <c name="MSK_IINF_MIO_PRESOLVED_NUMBINCONEVAR" val="51">
   <cmnt>Number of binary cone variables in the problem after the mixed-integer optimizer's presolve.</cmnt>
  </c>
  <c name="MSK_IINF_MIO_PRESOLVED_NUMINTCONEVAR" val="60">
   <cmnt>Number of integer cone variables in the problem after the mixed-integer optimizer's presolve.</cmnt>
  </c>
  <c name="MSK_IINF_MIO_PRESOLVED_NUMCONTCONEVAR" val="56">
   <cmnt>Number of continuous cone variables in the problem after the mixed-integer optimizer's presolve.</cmnt>
  </c>
  <c name="MSK_IINF_MIO_CLIQUE_TABLE_SIZE" val="20">
   <cmnt>Size of the clique table.</cmnt>
  </c>
  <c name="MSK_IINF_MIO_CONSTRUCT_SOLUTION" val="21">
   <cmnt>This item informs if |mosek| constructed an initial integer feasible solution.

* -1: tried, but failed,
* 0: no partial solution supplied by the user,
* 1: constructed feasible solution.</cmnt>
  </c>
  <c name="MSK_IINF_MIO_NUM_INT_SOLUTIONS" val="29">
   <cmnt>Number of integer feasible solutions that have been found.</cmnt>
  </c>
  <c name="MSK_IINF_MIO_OBJ_BOUND_DEFINED" val="49">
   <cmnt>Non-zero if a valid objective bound has been found, otherwise zero.</cmnt>
  </c>
  <c name="MSK_IINF_MIO_NUM_ACTIVE_NODES" val="23">
   <cmnt>Number of active branch and bound nodes.</cmnt>
  </c>
  <c name="MSK_IINF_MIO_NUM_RELAX" val="31">
   <cmnt>Number of relaxations solved during the optimization.</cmnt>
  </c>
  <c name="MSK_IINF_MIO_NUM_BRANCH" val="24">
   <cmnt>Number of branches performed during the optimization.</cmnt>
  </c>
  <c name="MSK_IINF_MIO_TOTAL_NUM_CUTS" val="67">
   <cmnt>Total number of cuts generated by the mixed-integer optimizer.</cmnt>
  </c>
  <c name="MSK_IINF_MIO_NUM_CMIR_CUTS" val="26">
   <cmnt>Number of Complemented Mixed Integer Rounding (CMIR) cuts.</cmnt>
  </c>
  <c name="MSK_IINF_MIO_NUM_CLIQUE_CUTS" val="25">
   <cmnt>Number of clique cuts.</cmnt>
  </c>
  <c name="MSK_IINF_MIO_NUM_IMPLIED_BOUND_CUTS" val="28">
   <cmnt>Number of implied bound cuts.</cmnt>
  </c>
  <c name="MSK_IINF_MIO_NUM_KNAPSACK_COVER_CUTS" val="30">
   <cmnt>Number of clique cuts.</cmnt>
  </c>
  <c name="MSK_IINF_MIO_NUM_GOMORY_CUTS" val="27">
   <cmnt>Number of Gomory cuts.</cmnt>
  </c>
  <c name="MSK_IINF_MIO_NUM_REPEATED_PRESOLVE" val="32">
   <cmnt>Number of times presolve was repeated at root.</cmnt>
  </c>
  <c name="MSK_IINF_MIO_USER_OBJ_CUT" val="68">
   <cmnt>If it is non-zero, then the objective cut is used.</cmnt>
  </c>
  <c name="MSK_IINF_MIO_RELGAP_SATISFIED" val="66">
   <cmnt>Non-zero if relative gap is within tolerances.</cmnt>
  </c>
  <c name="MSK_IINF_MIO_ABSGAP_SATISFIED" val="19">
   <cmnt>Non-zero if absolute gap is within tolerances.</cmnt>
  </c>
  <c name="MSK_IINF_RD_PROTYPE" val="80">
   <cmnt>Problem type.</cmnt>
  </c>
  <c name="MSK_IINF_RD_NUMCON" val="75">
   <cmnt>Number of constraints read.</cmnt>
  </c>
  <c name="MSK_IINF_RD_NUMVAR" val="79">
   <cmnt>Number of variables read.</cmnt>
  </c>
  <c name="MSK_IINF_RD_NUMBARVAR" val="74">
   <cmnt>Number of symmetric variables read.</cmnt>
  </c>
  <c name="MSK_IINF_RD_NUMINTVAR" val="77">
   <cmnt>Number of integer-constrained variables read.</cmnt>
  </c>
  <c name="MSK_IINF_RD_NUMQ" val="78">
   <cmnt>Number of nonempty Q matrices read.</cmnt>
  </c>
  <c name="MSK_IINF_SIM_DUAL_DEG_ITER" val="81">
   <cmnt>The number of dual degenerate iterations.</cmnt>
  </c>
  <c name="MSK_IINF_SIM_DUAL_INF_ITER" val="84">
   <cmnt>The number of iterations taken with dual infeasibility.</cmnt>
  </c>
  <c name="MSK_IINF_SIM_DUAL_HOTSTART_LU" val="83">
   <cmnt>If 1 then a valid basis factorization of full rank was located and used by the dual simplex algorithm.</cmnt>
  </c>
  <c name="MSK_IINF_SIM_PRIMAL_ITER" val="92">
   <cmnt>Number of primal simplex iterations during the last optimization.</cmnt>
  </c>
  <c name="MSK_IINF_SIM_DUAL_ITER" val="85">
   <cmnt>Number of dual simplex iterations during the last optimization.</cmnt>
  </c>
  <c name="MSK_IINF_INTPNT_NUM_THREADS" val="17">
   <cmnt>Number of threads that the interior-point optimizer is using.</cmnt>
  </c>
  <c name="MSK_IINF_SIM_PRIMAL_INF_ITER" val="91">
   <cmnt>The number of iterations taken with primal infeasibility.</cmnt>
  </c>
  <c name="MSK_IINF_SIM_PRIMAL_DEG_ITER" val="88">
   <cmnt>The number of primal degenerate iterations.</cmnt>
  </c>
  <c name="MSK_IINF_SIM_PRIMAL_HOTSTART" val="89">
   <cmnt>If 1 then the primal simplex algorithm is solving from an advanced basis.</cmnt>
  </c>
  <c name="MSK_IINF_SIM_PRIMAL_HOTSTART_LU" val="90">
   <cmnt>If 1 then a valid basis factorization of full rank was located and used by the primal simplex algorithm.</cmnt>
  </c>
  <c name="MSK_IINF_SIM_DUAL_HOTSTART" val="82">
   <cmnt>If 1 then the dual simplex algorithm is solving from an advanced basis.</cmnt>
  </c>
  <c name="MSK_IINF_SOL_ITR_PROSTA" val="98">
   <cmnt>Problem status of the interior-point solution. Updated after each optimization.</cmnt>
  </c>
  <c name="MSK_IINF_SOL_ITR_SOLSTA" val="99">
   <cmnt>Solution status of the interior-point solution. Updated after each optimization.</cmnt>
  </c>
  <c name="MSK_IINF_SOL_BAS_PROSTA" val="94">
   <cmnt>Problem status of the basic solution. Updated after each optimization.</cmnt>
  </c>
  <c name="MSK_IINF_SOL_BAS_SOLSTA" val="95">
   <cmnt>Solution status of the basic solution. Updated after each optimization.</cmnt>
  </c>
  <c name="MSK_IINF_SOL_ITG_PROSTA" val="96">
   <cmnt>Problem status of the integer solution. Updated after each optimization.</cmnt>
  </c>
  <c name="MSK_IINF_SOL_ITG_SOLSTA" val="97">
   <cmnt>Solution status of the integer solution. Updated after each optimization.</cmnt>
  </c>
  <c name="MSK_IINF_SIM_NUMCON" val="86">
   <cmnt>Number of constraints in the problem solved by the simplex optimizer.</cmnt>
  </c>
  <c name="MSK_IINF_SIM_NUMVAR" val="87">
   <cmnt>Number of variables in the problem solved by the simplex optimizer.</cmnt>
  </c>
  <c name="MSK_IINF_OPT_NUMCON" val="69">
   <cmnt>Number of constraints in the problem solved when the optimizer is called.</cmnt>
  </c>
  <c name="MSK_IINF_OPT_NUMVAR" val="70">
   <cmnt>Number of variables in the problem solved when the optimizer is called</cmnt>
  </c>
  <c name="MSK_IINF_STO_NUM_A_REALLOC" val="100">
   <cmnt>Number of times the storage for storing :math:`A` has been changed.
A large value may indicates that memory fragmentation may occur.</cmnt>
  </c>
  <c name="MSK_IINF_RD_NUMCONE" val="76">
   <cmnt>Number of conic constraints read.</cmnt>
  </c>
  <c name="MSK_IINF_SIM_SOLVE_DUAL" val="93">
   <cmnt>Is non-zero if dual problem is solved.</cmnt>
  </c>
  <c name="MSK_IINF_PURIFY_PRIMAL_SUCCESS" val="73">
   <cmnt>Is nonzero if the primal solution is purified.</cmnt>
  </c>
  <c name="MSK_IINF_PURIFY_DUAL_SUCCESS" val="72">
   <cmnt>Is nonzero if the dual solution is purified.</cmnt>
  </c>
 </sec>
 <sec id="MSKinftypee" type="enum">
  <cmnt>Information item types</cmnt>
  <c name="MSK_INF_DOU_TYPE" val="0">
   <cmnt>Is a double information type.</cmnt>
  </c>
  <c name="MSK_INF_INT_TYPE" val="1">
   <cmnt>Is an integer.</cmnt>
  </c>
  <c name="MSK_INF_LINT_TYPE" val="2">
   <cmnt>Is a long integer.</cmnt>
  </c>
 </sec>
 <sec id="MSKiomodee" type="constants">
  <cmnt>Input/output modes</cmnt>
  <c name="MSK_IOMODE_READ" val="0">
   <cmnt>The file is read-only.</cmnt>
  </c>
  <c name="MSK_IOMODE_WRITE" val="1">
   <cmnt>The file is write-only. If the file exists then it is truncated when it is opened. Otherwise it is created when it is opened.</cmnt>
  </c>
  <c name="MSK_IOMODE_READWRITE" val="2">
   <cmnt>The file is to read and write.</cmnt>
  </c>
 </sec>
 <sec id="MSKiparame" type="parameters">
  <cmnt>The enumeration type containing all integer parameters.</cmnt>
  <p name="MSK_IPAR_AUTO_UPDATE_SOL_INFO" val="3">
   <cmnt>Controls whether the solution information items are automatically updated after an optimization is performed.</cmnt>
   <values_from group="MSKonoffkeye">
    <ref name="MSK_ON"/>
    <ref name="MSK_OFF"/>
   </values_from>
   <default>MSK_off</default>
  </p>
  <p name="MSK_IPAR_REMOVE_UNUSED_SOLUTIONS" val="118">
   <cmnt>Removes unused solutions before the optimization is performed.</cmnt>
   <values_from group="MSKonoffkeye">
    <ref name="MSK_ON"/>
    <ref name="MSK_OFF"/>
   </values_from>
   <default>MSK_off</default>
  </p>
  <p name="MSK_IPAR_INTPNT_HOTSTART" val="18">
   <cmnt>Currently not in use.</cmnt>
   <values_from group="MSKintpnthotstarte">
    <ref name="MSK_INTPNT_HOTSTART_NONE"/>
    <ref name="MSK_INTPNT_HOTSTART_PRIMAL"/>
    <ref name="MSK_INTPNT_HOTSTART_DUAL"/>
    <ref name="MSK_INTPNT_HOTSTART_PRIMAL_DUAL"/>
   </values_from>
   <default>MSK_INTPNT_HOTSTART_none</default>
  </p>
  <p name="MSK_IPAR_INTPNT_PURIFY" val="26">
   <cmnt>Currently not in use.</cmnt>
   <values_from group="MSKpurifye">
    <ref name="MSK_PURIFY_NONE"/>
    <ref name="MSK_PURIFY_PRIMAL"/>
    <ref name="MSK_PURIFY_DUAL"/>
    <ref name="MSK_PURIFY_PRIMAL_DUAL"/>
    <ref name="MSK_PURIFY_AUTO"/>
   </values_from>
   <default>MSK_PURIFY_none</default>
  </p>
  <p name="MSK_IPAR_NUM_THREADS" val="87">
   <cmnt>Controls the number of threads employed by the optimizer. If set to 0 the number of threads used will be equal to the number of cores detected on the machine.

If using the conic optimizer, the value of this parameter set at first optimization remains constant through the lifetime of the process. |mosek| will allocate a thread pool of given size, and changing the parameter value later will have no effect. It will, however, remain possible to demand single-threaded execution by setting :msk:iparam:`intpnt_multi_thread`.

For the mixed-integer optimizer and interior-point linear optimizer there is no such restriction.</cmnt>
   <lower_bound>0</lower_bound>
   <upper_bound>+inf</upper_bound>
   <default>0</default>
  </p>
  <p name="MSK_IPAR_INTPNT_MULTI_THREAD" val="22">
   <cmnt>Controls whether the interior-point optimizers are allowed to employ multiple threads if more threads is available.</cmnt>
   <values_from group="MSKonoffkeye">
    <ref name="MSK_ON"/>
    <ref name="MSK_OFF"/>
   </values_from>
   <default>MSK_on</default>
  </p>
  <p name="MSK_IPAR_TIMING_LEVEL" val="152">
   <cmnt>Controls the amount of timing performed inside |mosek|.</cmnt>
   <lower_bound>0</lower_bound>
   <upper_bound>+inf</upper_bound>
   <default>1</default>
  </p>
  <p name="MSK_IPAR_MT_SPINCOUNT" val="86">
   <cmnt>Set the number of iterations to spin before sleeping.</cmnt>
   <lower_bound>0</lower_bound>
   <upper_bound>1000000000</upper_bound>
   <default>0</default>
  </p>
  <p name="MSK_IPAR_MAX_NUM_WARNINGS" val="60">
   <cmnt>Each warning is shown a limited number of times controlled by this parameter. A negative value is identical to infinite number of times.</cmnt>
   <lower_bound>-inf</lower_bound>
   <upper_bound>+inf</upper_bound>
   <default>10</default>
  </p>
  <p name="MSK_IPAR_OPTIMIZER" val="97">
   <cmnt>The parameter controls which optimizer is used to optimize the task.</cmnt>
   <values_from group="MSKoptimizertypee">
    <ref name="MSK_OPTIMIZER_FREE"/>
    <ref name="MSK_OPTIMIZER_INTPNT"/>
    <ref name="MSK_OPTIMIZER_CONIC"/>
    <ref name="MSK_OPTIMIZER_PRIMAL_SIMPLEX"/>
    <ref name="MSK_OPTIMIZER_DUAL_SIMPLEX"/>
    <ref name="MSK_OPTIMIZER_FREE_SIMPLEX"/>
    <ref name="MSK_OPTIMIZER_MIXED_INT"/>
   </values_from>
   <default>MSK_OPTIMIZER_FREE</default>
  </p>
  <p name="MSK_IPAR_BI_MAX_ITERATIONS" val="8">
   <cmnt>Controls the maximum number of
simplex iterations allowed to optimize
a basis after the basis identification.</cmnt>
   <lower_bound>0</lower_bound>
   <upper_bound>+inf</upper_bound>
   <default>1000000</default>
  </p>
  <p name="MSK_IPAR_LICENSE_TRH_EXPIRY_WRN" val="34">
   <cmnt>If a license feature expires in a numbers of days less than the value of this parameter then a warning will be issued.</cmnt>
   <lower_bound>0</lower_bound>
   <upper_bound>+inf</upper_bound>
   <default>7</default>
  </p>
  <p name="MSK_IPAR_LOG_INCLUDE_SUMMARY" val="45">
   <cmnt>.. msk_only:: optimizer

   If on, then the solution summary will be printed by :msk:func:`task.optimize`, so a separate call to :msk:func:`task.solutionsummary` is not necessary.

.. msk_only:: not optimizer

   Not relevant for this API.</cmnt>
   <values_from group="MSKonoffkeye">
    <ref name="MSK_ON"/>
    <ref name="MSK_OFF"/>
   </values_from>
   <default>MSK_off</default>
  </p>
  <p name="MSK_IPAR_LOG_CUT_SECOND_OPT" val="41">
   <cmnt>If a task is employed to solve a sequence of optimization problems, then the value of the log levels is reduced by the value
of this parameter. E.g :msk:iparam:`log` and :msk:iparam:`log_sim` are reduced by the value of this parameter
for the second and any subsequent optimizations.</cmnt>
   <lower_bound>0</lower_bound>
   <upper_bound>+inf</upper_bound>
   <default>1</default>
   <seealso key="MSK_IPAR_LOG"/>
   <seealso key="MSK_IPAR_LOG_INTPNT"/>
   <seealso key="MSK_IPAR_LOG_MIO"/>
   <seealso key="MSK_IPAR_LOG_SIM"/>
  </p>
  <p name="MSK_IPAR_LOG_ANA_PRO" val="37">
   <cmnt>Controls amount of output from the problem analyzer.</cmnt>
   <lower_bound>0</lower_bound>
   <upper_bound>+inf</upper_bound>
   <default>1</default>
  </p>
  <p name="MSK_IPAR_LOG_RESPONSE" val="53">
   <cmnt>Controls amount of output printed when response codes are reported. A higher level implies that more information is logged.</cmnt>
   <lower_bound>0</lower_bound>
   <upper_bound>+inf</upper_bound>
   <default>0</default>
  </p>
  <p name="MSK_IPAR_LOG_LOCAL_INFO" val="48">
   <cmnt>Controls whether local identifying information like
environment variables, filenames, IP addresses
etc. are printed to the log.

Note that this will only affect some functions. Some
functions that specifically emit system information
will not be affected.</cmnt>
   <values_from group="MSKonoffkeye">
    <ref name="MSK_ON"/>
    <ref name="MSK_OFF"/>
   </values_from>
   <default>MSK_on</default>
  </p>
  <p name="MSK_IPAR_LOG_BI" val="38">
   <cmnt>Controls the amount of output printed by the basis identification procedure. A higher level implies that more information is logged.</cmnt>
   <lower_bound>0</lower_bound>
   <upper_bound>+inf</upper_bound>
   <default>1</default>
  </p>
  <p name="MSK_IPAR_LOG_BI_FREQ" val="39">
   <cmnt>Controls how frequently the optimizer
outputs information about the basis identification
and how frequent the user-defined callback function
is called.</cmnt>
   <lower_bound>0</lower_bound>
   <upper_bound>+inf</upper_bound>
   <default>2500</default>
  </p>
  <p name="MSK_IPAR_BI_CLEAN_OPTIMIZER" val="5">
   <cmnt>Controls which simplex optimizer is used in the clean-up phase. Anything else than :msk:const:`optimizertype.primal_simplex` or :msk:const:`optimizertype.dual_simplex` is equivalent to :msk:const:`optimizertype.free_simplex`.</cmnt>
   <values_from group="MSKoptimizertypee">
    <ref name="MSK_OPTIMIZER_FREE"/>
    <ref name="MSK_OPTIMIZER_INTPNT"/>
    <ref name="MSK_OPTIMIZER_CONIC"/>
    <ref name="MSK_OPTIMIZER_PRIMAL_SIMPLEX"/>
    <ref name="MSK_OPTIMIZER_DUAL_SIMPLEX"/>
    <ref name="MSK_OPTIMIZER_FREE_SIMPLEX"/>
    <ref name="MSK_OPTIMIZER_MIXED_INT"/>
   </values_from>
   <default>MSK_OPTIMIZER_FREE</default>
  </p>
  <p name="MSK_IPAR_INTPNT_MAX_NUM_REFINEMENT_STEPS" val="21">
   <cmnt>Maximum number of steps to be used by the iterative
refinement of the search direction. A negative value
implies that the optimizer chooses the maximum number
of iterative refinement steps.</cmnt>
   <lower_bound>-inf</lower_bound>
   <upper_bound>+inf</upper_bound>
   <default>-1</default>
  </p>
  <p name="MSK_IPAR_INTPNT_STARTING_POINT" val="30">
   <cmnt>Starting point used by the interior-point optimizer.</cmnt>
   <values_from group="MSKstartpointtypee">
    <ref name="MSK_STARTING_POINT_FREE"/>
    <ref name="MSK_STARTING_POINT_GUESS"/>
    <ref name="MSK_STARTING_POINT_CONSTANT"/>
    <ref name="MSK_STARTING_POINT_SATISFY_BOUNDS"/>
   </values_from>
   <default>MSK_STARTING_POINT_FREE</default>
  </p>
  <p name="MSK_IPAR_INTPNT_DIFF_STEP" val="17">
   <cmnt>Controls whether different step sizes are allowed in the primal and dual space.</cmnt>
   <values_from group="MSKonoffkeye">
    <ref name="MSK_ON">Different step sizes are allowed.</ref>
    <ref name="MSK_OFF">Different step sizes are not allowed.</ref>
   </values_from>
   <default>MSK_ON</default>
  </p>
  <p name="MSK_IPAR_INTPNT_SCALING" val="28">
   <cmnt>Controls how the problem is scaled before the interior-point optimizer is used.</cmnt>
   <values_from group="MSKscalingtypee">
    <ref name="MSK_SCALING_FREE"/>
    <ref name="MSK_SCALING_NONE"/>
    <ref name="MSK_SCALING_MODERATE"/>
    <ref name="MSK_SCALING_AGGRESSIVE"/>
   </values_from>
   <default>MSK_SCALING_FREE</default>
  </p>
  <p name="MSK_IPAR_INTPNT_SOLVE_FORM" val="29">
   <cmnt>Controls whether the primal or the dual problem is solved.</cmnt>
   <values_from group="MSKsolveforme">
    <ref name="MSK_SOLVE_FREE"/>
    <ref name="MSK_SOLVE_PRIMAL"/>
    <ref name="MSK_SOLVE_DUAL"/>
   </values_from>
   <default>MSK_SOLVE_FREE</default>
  </p>
  <p name="MSK_IPAR_LOG_INTPNT" val="47">
   <cmnt>Controls amount of output printed
by the interior-point optimizer. A higher level implies that more information is logged.</cmnt>
   <lower_bound>0</lower_bound>
   <upper_bound>+inf</upper_bound>
   <default>1</default>
  </p>
  <p name="MSK_IPAR_INTPNT_MAX_ITERATIONS" val="19">
   <cmnt>Controls the maximum number of iterations allowed in the interior-point optimizer.</cmnt>
   <lower_bound>0</lower_bound>
   <upper_bound>+inf</upper_bound>
   <default>400</default>
  </p>
  <p name="MSK_IPAR_INTPNT_OFF_COL_TRH" val="23">
   <cmnt>Controls how many offending columns are detected in the Jacobian of the constraint matrix.

+----------+-----------------------------------------------+
|:math:`0` |  no detection                                 |
+----------+-----------------------------------------------+
|:math:`1` |  aggressive detection                         |
+----------+-----------------------------------------------+
|:math:`&gt;1`|  higher values mean less aggressive detection |
+----------+-----------------------------------------------+</cmnt>
   <lower_bound>0</lower_bound>
   <upper_bound>+inf</upper_bound>
   <default>40</default>
  </p>
  <p name="MSK_IPAR_INTPNT_ORDER_METHOD" val="25">
   <cmnt>Controls the ordering strategy used by the interior-point
optimizer when factorizing the Newton
equation system.</cmnt>
   <values_from group="MSKorderingtypee">
    <ref name="MSK_ORDER_METHOD_FREE"/>
    <ref name="MSK_ORDER_METHOD_APPMINLOC"/>
    <ref name="MSK_ORDER_METHOD_EXPERIMENTAL"/>
    <ref name="MSK_ORDER_METHOD_TRY_GRAPHPAR"/>
    <ref name="MSK_ORDER_METHOD_FORCE_GRAPHPAR"/>
    <ref name="MSK_ORDER_METHOD_NONE"/>
   </values_from>
   <default>MSK_ORDER_METHOD_FREE</default>
  </p>
  <p name="MSK_IPAR_INTPNT_ORDER_GP_NUM_SEEDS" val="24">
   <cmnt>The GP ordering is dependent on a random seed. Therefore, trying several random seeds may lead to a better ordering.
This parameter controls the number of random seeds tried.

A value of 0 means that MOSEK makes the choice.</cmnt>
   <lower_bound>0</lower_bound>
   <upper_bound>+inf</upper_bound>
   <default>0</default>
  </p>
  <p name="MSK_IPAR_INTPNT_BASIS" val="16">
   <cmnt>Controls whether the interior-point optimizer also
computes an optimal basis.</cmnt>
   <values_from group="MSKbasindtypee">
    <ref name="MSK_BI_NEVER"/>
    <ref name="MSK_BI_ALWAYS"/>
    <ref name="MSK_BI_NO_ERROR"/>
    <ref name="MSK_BI_IF_FEASIBLE"/>
    <ref name="MSK_BI_RESERVERED"/>
   </values_from>
   <default>MSK_BI_ALWAYS</default>
   <seealso key="MSK_IPAR_BI_IGNORE_MAX_ITER"/>
   <seealso key="MSK_IPAR_BI_IGNORE_NUM_ERROR"/>
   <seealso key="MSK_IPAR_BI_MAX_ITERATIONS"/>
   <seealso key="MSK_IPAR_BI_CLEAN_OPTIMIZER"/>
  </p>
  <p name="MSK_IPAR_BI_IGNORE_MAX_ITER" val="6">
   <cmnt>If the parameter :msk:iparam:`intpnt_basis` has the value :msk:const:`basindtype.no_error` and the interior-point optimizer has terminated due to maximum number of iterations, then basis identification is performed if this parameter has the value :msk:const:`onoffkey.on`.</cmnt>
   <values_from group="MSKonoffkeye">
    <ref name="MSK_ON"/>
    <ref name="MSK_OFF"/>
   </values_from>
   <default>MSK_OFF</default>
  </p>
  <p name="MSK_IPAR_BI_IGNORE_NUM_ERROR" val="7">
   <cmnt>If the parameter :msk:iparam:`intpnt_basis` has the value :msk:const:`basindtype.no_error` and the interior-point optimizer has terminated due to a numerical problem, then basis identification is performed if this parameter has the value :msk:const:`onoffkey.on`.</cmnt>
   <values_from group="MSKonoffkeye">
    <ref name="MSK_ON"/>
    <ref name="MSK_OFF"/>
   </values_from>
   <default>MSK_OFF</default>
  </p>
  <p name="MSK_IPAR_INTPNT_MAX_NUM_COR" val="20">
   <cmnt>Controls the maximum number of correctors allowed by the multiple corrector procedure. A negative value means that |mosek| is making the choice.</cmnt>
   <lower_bound>-1</lower_bound>
   <upper_bound>+inf</upper_bound>
   <default>-1</default>
  </p>
  <p name="MSK_IPAR_PRESOLVE_USE" val="108">
   <cmnt>Controls whether the presolve is applied to a problem before it is optimized.</cmnt>
   <values_from group="MSKpresolvemodee">
    <ref name="MSK_PRESOLVE_MODE_OFF"/>
    <ref name="MSK_PRESOLVE_MODE_ON"/>
    <ref name="MSK_PRESOLVE_MODE_FREE"/>
   </values_from>
   <default>MSK_PRESOLVE_MODE_FREE</default>
  </p>
  <p name="MSK_IPAR_PRESOLVE_LEVEL" val="102">
   <cmnt>Currently not used.</cmnt>
   <lower_bound>-inf</lower_bound>
   <upper_bound>+inf</upper_bound>
   <default>-1</default>
  </p>
  <p name="MSK_IPAR_LOG_PRESOLVE" val="52">
   <cmnt>Controls amount of output printed by the presolve procedure. A higher level implies that more information is logged.</cmnt>
   <lower_bound>0</lower_bound>
   <upper_bound>+inf</upper_bound>
   <default>1</default>
  </p>
  <p name="MSK_IPAR_PRESOLVE_LINDEP_USE" val="105">
   <cmnt>Controls whether the linear constraints are checked for linear dependencies.</cmnt>
   <values_from group="MSKonoffkeye">
    <ref name="MSK_ON"/>
    <ref name="MSK_OFF"/>
   </values_from>
   <default>MSK_ON</default>
  </p>
  <p name="MSK_IPAR_PRESOLVE_MAX_NUM_PASS" val="106">
   <cmnt>Control the maximum number of times presolve passes over the problem. A negative value implies |mosek| decides.</cmnt>
   <lower_bound>-inf</lower_bound>
   <upper_bound>+inf</upper_bound>
   <default>-1</default>
  </p>
  <p name="MSK_IPAR_PRESOLVE_ELIMINATOR_MAX_NUM_TRIES" val="101">
   <cmnt>Control the maximum number of times the eliminator is tried. A negative value implies |mosek| decides.</cmnt>
   <lower_bound>-inf</lower_bound>
   <upper_bound>+inf</upper_bound>
   <default>-1</default>
  </p>
  <p name="MSK_IPAR_PRESOLVE_ELIMINATOR_MAX_FILL" val="100">
   <cmnt>Controls the maximum amount of fill-in that can be created by one pivot in the elimination phase
of the presolve. A negative value means the parameter value is selected automatically.</cmnt>
   <lower_bound>-inf</lower_bound>
   <upper_bound>+inf</upper_bound>
   <default>-1</default>
  </p>
  <p name="MSK_IPAR_PRESOLVE_MAX_NUM_REDUCTIONS" val="107">
   <cmnt>Controls the maximum number of reductions performed by the
presolve. The value of the parameter is normally only changed
in connection with debugging. A negative value implies that an
infinite number of reductions are allowed.</cmnt>
   <lower_bound>-inf</lower_bound>
   <upper_bound>+inf</upper_bound>
   <default>-1</default>
  </p>
  <p name="MSK_IPAR_SIM_STABILITY_PRIORITY" val="145">
   <cmnt>Controls how high priority the numerical stability should be given.</cmnt>
   <lower_bound>0</lower_bound>
   <upper_bound>100</upper_bound>
   <default>50</default>
  </p>
  <p name="MSK_IPAR_SIM_PRIMAL_CRASH" val="134">
   <cmnt>Controls whether crashing is performed in the primal simplex optimizer.
In general, if a basis consists of more than (100-this parameter value)\%
fixed variables, then a crash will be performed.</cmnt>
   <lower_bound>0</lower_bound>
   <upper_bound>+inf</upper_bound>
   <default>90</default>
  </p>
  <p name="MSK_IPAR_LOG_SIM" val="56">
   <cmnt>Controls amount of output printed by the simplex optimizer. A higher level implies that more information is logged.</cmnt>
   <lower_bound>0</lower_bound>
   <upper_bound>+inf</upper_bound>
   <default>4</default>
  </p>
  <p name="MSK_IPAR_LOG_SIM_MINOR" val="58">
   <cmnt>Currently not in use.</cmnt>
   <lower_bound>0</lower_bound>
   <upper_bound>+inf</upper_bound>
   <default>1</default>
  </p>
  <p name="MSK_IPAR_LOG_SIM_FREQ" val="57">
   <cmnt>Controls how frequent the simplex optimizer
outputs information about the optimization
and how frequent the user-defined callback function
is called.</cmnt>
   <lower_bound>0</lower_bound>
   <upper_bound>+inf</upper_bound>
   <default>1000</default>
  </p>
  <p name="MSK_IPAR_SIM_PRIMAL_RESTRICT_SELECTION" val="136">
   <cmnt>The primal simplex optimizer can use a so-called restricted selection/pricing strategy to
choose the outgoing variable. Hence, if restricted selection is applied, then the primal simplex optimizer first
choose a subset of all the potential incoming variables. Next, for some time it will choose the incoming
variable only among the subset. From time to time the subset is redefined.
A larger value of this parameter implies that the optimizer will be more aggressive in its
restriction strategy, i.e. a value of 0 implies that the restriction strategy is not applied at all.</cmnt>
   <lower_bound>0</lower_bound>
   <upper_bound>100</upper_bound>
   <default>50</default>
  </p>
  <p name="MSK_IPAR_SIM_PRIMAL_SELECTION" val="137">
   <cmnt>Controls the choice of the incoming variable,
known as the selection strategy, in the primal
simplex optimizer.</cmnt>
   <values_from group="MSKsimseltypee">
    <ref name="MSK_SIM_SELECTION_FREE"/>
    <ref name="MSK_SIM_SELECTION_FULL"/>
    <ref name="MSK_SIM_SELECTION_ASE"/>
    <ref name="MSK_SIM_SELECTION_DEVEX"/>
    <ref name="MSK_SIM_SELECTION_SE"/>
    <ref name="MSK_SIM_SELECTION_PARTIAL"/>
   </values_from>
   <default>MSK_SIM_SELECTION_FREE</default>
  </p>
  <p name="MSK_IPAR_SIM_DUAL_RESTRICT_SELECTION" val="126">
   <cmnt>The dual simplex optimizer can use a so-called restricted selection/pricing strategy to
choose the outgoing variable. Hence, if restricted selection is applied, then the dual simplex optimizer first
choose a subset of all the potential outgoing variables. Next, for some time it will choose the outgoing
variable only among the subset. From time to time the subset is redefined.
A larger value of this parameter implies that the optimizer will be more aggressive in its
restriction strategy, i.e. a value of 0 implies that the restriction strategy is not applied at all.</cmnt>
   <lower_bound>0</lower_bound>
   <upper_bound>100</upper_bound>
   <default>50</default>
  </p>
  <p name="MSK_IPAR_SIM_DUAL_SELECTION" val="127">
   <cmnt>Controls the choice of the incoming variable,
known as the selection strategy, in the dual
simplex optimizer.</cmnt>
   <values_from group="MSKsimseltypee">
    <ref name="MSK_SIM_SELECTION_FREE"/>
    <ref name="MSK_SIM_SELECTION_FULL"/>
    <ref name="MSK_SIM_SELECTION_ASE"/>
    <ref name="MSK_SIM_SELECTION_DEVEX"/>
    <ref name="MSK_SIM_SELECTION_SE"/>
    <ref name="MSK_SIM_SELECTION_PARTIAL"/>
   </values_from>
   <default>MSK_SIM_SELECTION_FREE</default>
  </p>
  <p name="MSK_IPAR_SIM_MAX_ITERATIONS" val="131">
   <cmnt>Maximum number of iterations that can be used by a simplex optimizer.</cmnt>
   <lower_bound>0</lower_bound>
   <upper_bound>+inf</upper_bound>
   <default>10000000</default>
  </p>
  <p name="MSK_IPAR_SIM_HOTSTART_LU" val="130">
   <cmnt>Determines if the simplex optimizer should exploit the initial factorization.</cmnt>
   <values_from group="MSKonoffkeye">
    <ref name="MSK_ON">Factorization is reused if possible.</ref>
    <ref name="MSK_OFF">Factorization is recomputed.</ref>
   </values_from>
   <default>MSK_ON</default>
  </p>
  <p name="MSK_IPAR_SIM_REFACTOR_FREQ" val="138">
   <cmnt>Controls how frequent the basis is refactorized.
The value 0 means that the optimizer determines
the best point of refactorization.
It is strongly recommended NOT to change this parameter.</cmnt>
   <lower_bound>0</lower_bound>
   <upper_bound>+inf</upper_bound>
   <default>0</default>
  </p>
  <p name="MSK_IPAR_SIM_SEED" val="143">
   <cmnt>Sets the random seed used for randomization in the simplex optimizers.</cmnt>
   <lower_bound>0</lower_bound>
   <upper_bound>32749</upper_bound>
   <default>23456</default>
  </p>
  <p name="MSK_IPAR_MIO_MODE" val="75">
   <cmnt>Controls whether the optimizer includes
the integer restrictions when solving a
(mixed) integer optimization problem.</cmnt>
   <values_from group="MSKmiomodee">
    <ref name="MSK_MIO_MODE_IGNORED"/>
    <ref name="MSK_MIO_MODE_SATISFIED"/>
   </values_from>
   <default>MSK_MIO_MODE_SATISFIED</default>
  </p>
  <p name="MSK_IPAR_LOG_MIO" val="49">
   <cmnt>Controls the log level for the mixed-integer optimizer. A higher level implies that more information is logged.</cmnt>
   <lower_bound>0</lower_bound>
   <upper_bound>+inf</upper_bound>
   <default>4</default>
  </p>
  <p name="MSK_IPAR_LOG_MIO_FREQ" val="50">
   <cmnt>Controls how frequent the mixed-integer optimizer prints the log line. It
will print line every time :msk:iparam:`log_mio_freq` relaxations have been solved.</cmnt>
   <lower_bound>-inf</lower_bound>
   <upper_bound>+inf</upper_bound>
   <default>10</default>
  </p>
  <p name="MSK_IPAR_MIO_MAX_NUM_RELAXS" val="72">
   <cmnt>Maximum number of relaxations allowed during the branch and bound search. A negative
value means infinite.</cmnt>
   <lower_bound>-inf</lower_bound>
   <upper_bound>+inf</upper_bound>
   <default>-1</default>
  </p>
  <p name="MSK_IPAR_MIO_MAX_NUM_BRANCHES" val="71">
   <cmnt>Maximum number of branches allowed during the branch and bound search. A negative
value means infinite.</cmnt>
   <lower_bound>-inf</lower_bound>
   <upper_bound>+inf</upper_bound>
   <default>-1</default>
  </p>
  <p name="MSK_IPAR_MIO_MAX_NUM_ROOT_CUT_ROUNDS" val="73">
   <cmnt>Maximum number of cut separation rounds at the root node.</cmnt>
   <lower_bound>0</lower_bound>
   <upper_bound>+inf</upper_bound>
   <default>100</default>
  </p>
  <p name="MSK_IPAR_MIO_MAX_NUM_SOLUTIONS" val="74">
   <cmnt>The mixed-integer optimizer can be terminated after a certain number of different feasible
solutions has been located. If this parameter has the value :math:`n&gt;0`, then the mixed-integer optimizer
will be terminated when :math:`n` feasible solutions have been located.</cmnt>
   <lower_bound>-inf</lower_bound>
   <upper_bound>+inf</upper_bound>
   <default>-1</default>
  </p>
  <p name="MSK_IPAR_MIO_NODE_SELECTION" val="77">
   <cmnt>Controls the node selection strategy employed by the mixed-integer optimizer.</cmnt>
   <values_from group="MSKmionodeseltypee">
    <ref name="MSK_MIO_NODE_SELECTION_FREE"/>
    <ref name="MSK_MIO_NODE_SELECTION_FIRST"/>
    <ref name="MSK_MIO_NODE_SELECTION_BEST"/>
    <ref name="MSK_MIO_NODE_SELECTION_PSEUDO"/>
   </values_from>
   <default>MSK_MIO_NODE_SELECTION_FREE</default>
  </p>
  <p name="MSK_IPAR_MIO_HEURISTIC_LEVEL" val="70">
   <cmnt>Controls the heuristic employed by the mixed-integer
optimizer to locate an initial good integer feasible
solution.  A value of zero means the heuristic is not used
at all. A larger value than :math:`0` means that a gradually more
sophisticated heuristic is used which is computationally
more expensive. A negative value implies that the optimizer
chooses the heuristic. Normally a value around :math:`3` to :math:`5`
should be optimal.</cmnt>
   <lower_bound>-inf</lower_bound>
   <upper_bound>+inf</upper_bound>
   <default>-1</default>
  </p>
  <p name="MSK_IPAR_MIO_PROBING_LEVEL" val="79">
   <cmnt>Controls the amount of probing employed by the mixed-integer
optimizer in presolve.

* :math:`-1`. The optimizer chooses the level of probing employed
* :math:`0`. Probing is disabled
* :math:`1`. A low amount of probing is employed
* :math:`2`. A medium amount of probing is employed
* :math:`3`. A high amount of probing is employed</cmnt>
   <lower_bound>-1</lower_bound>
   <upper_bound>3</upper_bound>
   <default>-1</default>
  </p>
  <p name="MSK_IPAR_MIO_CUT_SELECTION_LEVEL" val="68">
   <cmnt>Controls how aggressively generated cuts are selected to be included in the relaxation.

* :math:`-1`. The optimizer chooses the level of cut selection
* :math:`0`. Generated cuts less likely to be added to the relaxation
* :math:`1`. Cuts are more aggressively selected to be included in the relaxation</cmnt>
   <lower_bound>-1</lower_bound>
   <upper_bound>+1</upper_bound>
   <default>-1</default>
  </p>
  <p name="MSK_IPAR_MIO_VB_DETECTION_LEVEL" val="85">
   <cmnt>Controls how much effort is put into detecting variable bounds.

* :math:`-1`. The optimizer chooses
* :math:`0`. No variable bounds are detected
* :math:`1`. Only detect variable bounds that are directly represented in the problem
* :math:`2`. Detect variable bounds in probing</cmnt>
   <lower_bound>-1</lower_bound>
   <upper_bound>+2</upper_bound>
   <default>-1</default>
  </p>
  <p name="MSK_IPAR_MIO_BRANCH_DIR" val="61">
   <cmnt>Controls whether the mixed-integer optimizer is branching up or down by default.</cmnt>
   <values_from group="MSKbranchdire">
    <ref name="MSK_BRANCH_DIR_FREE"/>
    <ref name="MSK_BRANCH_DIR_UP"/>
    <ref name="MSK_BRANCH_DIR_DOWN"/>
    <ref name="MSK_BRANCH_DIR_NEAR"/>
    <ref name="MSK_BRANCH_DIR_FAR"/>
    <ref name="MSK_BRANCH_DIR_ROOT_LP"/>
    <ref name="MSK_BRANCH_DIR_GUIDED"/>
    <ref name="MSK_BRANCH_DIR_PSEUDOCOST"/>
   </values_from>
   <default>MSK_BRANCH_DIR_FREE</default>
  </p>
  <p name="MSK_IPAR_MIO_ROOT_OPTIMIZER" val="82">
   <cmnt>Controls which optimizer is employed at the root node in the mixed-integer optimizer.</cmnt>
   <values_from group="MSKoptimizertypee">
    <ref name="MSK_OPTIMIZER_FREE"/>
    <ref name="MSK_OPTIMIZER_INTPNT"/>
    <ref name="MSK_OPTIMIZER_CONIC"/>
    <ref name="MSK_OPTIMIZER_PRIMAL_SIMPLEX"/>
    <ref name="MSK_OPTIMIZER_DUAL_SIMPLEX"/>
    <ref name="MSK_OPTIMIZER_FREE_SIMPLEX"/>
    <ref name="MSK_OPTIMIZER_MIXED_INT"/>
   </values_from>
   <default>MSK_OPTIMIZER_FREE</default>
  </p>
  <p name="MSK_IPAR_MIO_NODE_OPTIMIZER" val="76">
   <cmnt>Controls which optimizer is employed at the non-root nodes in the mixed-integer optimizer.</cmnt>
   <values_from group="MSKoptimizertypee">
    <ref name="MSK_OPTIMIZER_FREE"/>
    <ref name="MSK_OPTIMIZER_INTPNT"/>
    <ref name="MSK_OPTIMIZER_CONIC"/>
    <ref name="MSK_OPTIMIZER_PRIMAL_SIMPLEX"/>
    <ref name="MSK_OPTIMIZER_DUAL_SIMPLEX"/>
    <ref name="MSK_OPTIMIZER_FREE_SIMPLEX"/>
    <ref name="MSK_OPTIMIZER_MIXED_INT"/>
   </values_from>
   <default>MSK_OPTIMIZER_FREE</default>
  </p>
  <p name="MSK_IPAR_MIO_PERSPECTIVE_REFORMULATE" val="78">
   <cmnt>Enables or disables perspective reformulation in presolve.</cmnt>
   <values_from group="MSKonoffkeye">
    <ref name="MSK_ON"/>
    <ref name="MSK_OFF"/>
   </values_from>
   <default>MSK_ON</default>
  </p>
  <p name="MSK_IPAR_MIO_PROPAGATE_OBJECTIVE_CONSTRAINT" val="80">
   <cmnt>Use objective domain propagation.</cmnt>
   <values_from group="MSKonoffkeye">
    <ref name="MSK_ON"/>
    <ref name="MSK_OFF"/>
   </values_from>
   <default>MSK_OFF</default>
  </p>
  <p name="MSK_IPAR_MIO_SEED" val="84">
   <cmnt>Sets the random seed used for randomization in the mixed integer optimizer.
Selecting a different seed can change the path the optimizer takes to the optimal solution.</cmnt>
   <lower_bound>0</lower_bound>
   <upper_bound>+inf</upper_bound>
   <default>42</default>
  </p>
  <p name="MSK_IPAR_MIO_CONIC_OUTER_APPROXIMATION" val="62">
   <cmnt>If this option is turned on outer approximation is used when solving relaxations of conic problems; otherwise interior point is used.</cmnt>
   <values_from group="MSKonoffkeye">
    <ref name="MSK_ON"/>
    <ref name="MSK_OFF"/>
   </values_from>
   <default>MSK_OFF</default>
  </p>
  <p name="MSK_IPAR_READ_KEEP_FREE_CON" val="112">
   <cmnt>Controls whether the free constraints are included in the problem.</cmnt>
   <values_from group="MSKonoffkeye">
    <ref name="MSK_ON">The free constraints are kept.</ref>
    <ref name="MSK_OFF">The free constraints are discarded.</ref>
   </values_from>
   <default>MSK_OFF</default>
  </p>
  <p name="MSK_IPAR_READ_MPS_FORMAT" val="115">
   <cmnt>Controls how strictly the MPS file reader interprets the MPS format.</cmnt>
   <values_from group="MSKmpsformate">
    <ref name="MSK_MPS_FORMAT_STRICT"/>
    <ref name="MSK_MPS_FORMAT_RELAXED"/>
    <ref name="MSK_MPS_FORMAT_FREE"/>
    <ref name="MSK_MPS_FORMAT_CPLEX"/>
   </values_from>
   <default>MSK_MPS_FORMAT_FREE</default>
  </p>
  <p name="MSK_IPAR_WRITE_MPS_FORMAT" val="170">
   <cmnt>Controls in which format the MPS is written.</cmnt>
   <values_from group="MSKmpsformate">
    <ref name="MSK_MPS_FORMAT_STRICT"/>
    <ref name="MSK_MPS_FORMAT_RELAXED"/>
    <ref name="MSK_MPS_FORMAT_FREE"/>
    <ref name="MSK_MPS_FORMAT_CPLEX"/>
   </values_from>
   <default>MSK_MPS_FORMAT_FREE</default>
  </p>
  <p name="MSK_IPAR_READ_MPS_WIDTH" val="116">
   <cmnt>Controls the maximal number of characters allowed in one line of the MPS file.</cmnt>
   <lower_bound>80</lower_bound>
   <upper_bound>+inf</upper_bound>
   <default>1024</default>
  </p>
  <p name="MSK_IPAR_READ_DEBUG" val="111">
   <cmnt>Turns on additional debugging information when reading files.</cmnt>
   <values_from group="MSKonoffkeye">
    <ref name="MSK_ON"/>
    <ref name="MSK_OFF"/>
   </values_from>
   <default>MSK_off</default>
  </p>
  <p name="MSK_IPAR_READ_LP_QUOTED_NAMES" val="114">
   <cmnt>If a name is in quotes when reading an LP file, the quotes will be removed.</cmnt>
   <values_from group="MSKonoffkeye">
    <ref name="MSK_ON"/>
    <ref name="MSK_OFF"/>
   </values_from>
   <default>MSK_ON</default>
  </p>
  <p name="MSK_IPAR_WRITE_DATA_PARAM" val="157">
   <cmnt>If this option is turned on the parameter settings are written to the
data file as parameters.</cmnt>
   <values_from group="MSKonoffkeye">
    <ref name="MSK_ON"/>
    <ref name="MSK_OFF"/>
   </values_from>
   <default>MSK_OFF</default>
  </p>
  <p name="MSK_IPAR_WRITE_FREE_CON" val="158">
   <cmnt>Controls whether the free
constraints are written to the
data file.</cmnt>
   <values_from group="MSKonoffkeye">
    <ref name="MSK_ON"/>
    <ref name="MSK_OFF"/>
   </values_from>
   <default>MSK_ON</default>
  </p>
  <p name="MSK_IPAR_WRITE_GENERIC_NAMES" val="159">
   <cmnt>Controls whether generic names should be used instead of user-defined names when writing to the data file.</cmnt>
   <values_from group="MSKonoffkeye">
    <ref name="MSK_ON"/>
    <ref name="MSK_OFF"/>
   </values_from>
   <default>MSK_OFF</default>
  </p>
  <p name="MSK_IPAR_WRITE_GENERIC_NAMES_IO" val="160">
   <cmnt>Index origin used in  generic names.</cmnt>
   <lower_bound>0</lower_bound>
   <upper_bound>+inf</upper_bound>
   <default>1</default>
  </p>
  <p name="MSK_IPAR_WRITE_COMPRESSION" val="156">
   <cmnt>Controls whether the data file is compressed while it is written.
0 means no compression while higher values mean more compression.</cmnt>
   <lower_bound>0</lower_bound>
   <upper_bound>+inf</upper_bound>
   <default>9</default>
  </p>
  <p name="MSK_IPAR_WRITE_MPS_INT" val="171">
   <cmnt>Controls if  marker records are written to the MPS file
to indicate whether variables are integer restricted.</cmnt>
   <values_from group="MSKonoffkeye">
    <ref name="MSK_ON"/>
    <ref name="MSK_OFF"/>
   </values_from>
   <default>MSK_ON</default>
  </p>
  <p name="MSK_IPAR_WRITE_LP_STRICT_FORMAT" val="168">
   <cmnt>Controls whether LP  output files satisfy the LP format strictly.</cmnt>
   <values_from group="MSKonoffkeye">
    <ref name="MSK_ON"/>
    <ref name="MSK_OFF"/>
   </values_from>
   <default>MSK_OFF</default>
  </p>
  <p name="MSK_IPAR_WRITE_LP_QUOTED_NAMES" val="167">
   <cmnt>If this option is turned on, then |mosek| will quote invalid LP names when writing an LP file.</cmnt>
   <values_from group="MSKonoffkeye">
    <ref name="MSK_ON"/>
    <ref name="MSK_OFF"/>
   </values_from>
   <default>MSK_ON</default>
  </p>
  <p name="MSK_IPAR_WRITE_LP_LINE_WIDTH" val="166">
   <cmnt>Maximum width of line in an LP file written by |mosek|.</cmnt>
   <lower_bound>40</lower_bound>
   <upper_bound>+inf</upper_bound>
   <default>80</default>
  </p>
  <p name="MSK_IPAR_WRITE_LP_TERMS_PER_LINE" val="169">
   <cmnt>Maximum number of terms on a single line in an LP file written by |mosek|. 0 means unlimited.</cmnt>
   <lower_bound>0</lower_bound>
   <upper_bound>+inf</upper_bound>
   <default>10</default>
  </p>
  <p name="MSK_IPAR_WRITE_LP_FULL_OBJ" val="165">
   <cmnt>Write all variables, including the ones with 0-coefficients, in the objective.</cmnt>
   <values_from group="MSKonoffkeye">
    <ref name="MSK_ON"/>
    <ref name="MSK_OFF"/>
   </values_from>
   <default>MSK_ON</default>
  </p>
  <p name="MSK_IPAR_WRITE_PRECISION" val="172">
   <cmnt>Controls the precision with which ``double``
numbers are printed in the MPS data file. In general it
is not worthwhile to use a value higher than 15.</cmnt>
   <lower_bound>0</lower_bound>
   <upper_bound>+inf</upper_bound>
   <default>15</default>
  </p>
  <p name="MSK_IPAR_WRITE_SOL_IGNORE_INVALID_NAMES" val="176">
   <cmnt>Even if the names are invalid MPS names, then they are employed when writing the solution file.</cmnt>
   <values_from group="MSKonoffkeye">
    <ref name="MSK_ON"/>
    <ref name="MSK_OFF"/>
   </values_from>
   <default>MSK_OFF</default>
  </p>
  <p name="MSK_IPAR_WRITE_SOL_HEAD" val="175">
   <cmnt>Controls whether the header section is written to the
solution file.</cmnt>
   <values_from group="MSKonoffkeye">
    <ref name="MSK_ON"/>
    <ref name="MSK_OFF"/>
   </values_from>
   <default>MSK_ON</default>
  </p>
  <p name="MSK_IPAR_WRITE_SOL_CONSTRAINTS" val="174">
   <cmnt>Controls whether the constraint section is written to the
solution file.</cmnt>
   <values_from group="MSKonoffkeye">
    <ref name="MSK_ON"/>
    <ref name="MSK_OFF"/>
   </values_from>
   <default>MSK_ON</default>
  </p>
  <p name="MSK_IPAR_WRITE_SOL_VARIABLES" val="177">
   <cmnt>Controls whether the variables section is written to the
solution file.</cmnt>
   <values_from group="MSKonoffkeye">
    <ref name="MSK_ON"/>
    <ref name="MSK_OFF"/>
   </values_from>
   <default>MSK_ON</default>
  </p>
  <p name="MSK_IPAR_WRITE_SOL_BARVARIABLES" val="173">
   <cmnt>Controls whether the symmetric matrix variables section is written to the
solution file.</cmnt>
   <values_from group="MSKonoffkeye">
    <ref name="MSK_ON"/>
    <ref name="MSK_OFF"/>
   </values_from>
   <default>MSK_ON</default>
  </p>
  <p name="MSK_IPAR_WRITE_BAS_HEAD" val="154">
   <cmnt>Controls whether the header section is written to the
basic solution file.</cmnt>
   <values_from group="MSKonoffkeye">
    <ref name="MSK_ON"/>
    <ref name="MSK_OFF"/>
   </values_from>
   <default>MSK_ON</default>
  </p>
  <p name="MSK_IPAR_WRITE_BAS_CONSTRAINTS" val="153">
   <cmnt>Controls whether the constraint section is written to the
basic solution file.</cmnt>
   <values_from group="MSKonoffkeye">
    <ref name="MSK_ON"/>
    <ref name="MSK_OFF"/>
   </values_from>
   <default>MSK_ON</default>
  </p>
  <p name="MSK_IPAR_WRITE_BAS_VARIABLES" val="155">
   <cmnt>Controls whether the variables section is written to the
basic solution file.</cmnt>
   <values_from group="MSKonoffkeye">
    <ref name="MSK_ON"/>
    <ref name="MSK_OFF"/>
   </values_from>
   <default>MSK_ON</default>
  </p>
  <p name="MSK_IPAR_WRITE_INT_HEAD" val="163">
   <cmnt>Controls whether the header section is written to the
integer solution file.</cmnt>
   <values_from group="MSKonoffkeye">
    <ref name="MSK_ON"/>
    <ref name="MSK_OFF"/>
   </values_from>
   <default>MSK_ON</default>
  </p>
  <p name="MSK_IPAR_WRITE_INT_CONSTRAINTS" val="162">
   <cmnt>Controls whether the constraint section is written to the
integer solution file.</cmnt>
   <values_from group="MSKonoffkeye">
    <ref name="MSK_ON"/>
    <ref name="MSK_OFF"/>
   </values_from>
   <default>MSK_ON</default>
  </p>
  <p name="MSK_IPAR_WRITE_INT_VARIABLES" val="164">
   <cmnt>Controls whether the variables section is written to the
integer solution file.</cmnt>
   <values_from group="MSKonoffkeye">
    <ref name="MSK_ON"/>
    <ref name="MSK_OFF"/>
   </values_from>
   <default>MSK_ON</default>
  </p>
  <p name="MSK_IPAR_SOL_READ_NAME_WIDTH" val="149">
   <cmnt>When a solution is read by |mosek| and some constraint, variable or cone names contain blanks, then a maximum name width much be specified. A negative value implies that no name contain blanks.</cmnt>
   <lower_bound>-inf</lower_bound>
   <upper_bound>+inf</upper_bound>
   <default>-1</default>
  </p>
  <p name="MSK_IPAR_SOL_READ_WIDTH" val="150">
   <cmnt>Controls the maximal acceptable width of line in the solutions when read by |mosek|.</cmnt>
   <lower_bound>80</lower_bound>
   <upper_bound>+inf</upper_bound>
   <default>1024</default>
  </p>
  <p name="MSK_IPAR_INFEAS_REPORT_AUTO" val="14">
   <cmnt>Controls whether an infeasibility report is automatically
produced after the optimization if the problem is primal or dual
infeasible.</cmnt>
   <values_from group="MSKonoffkeye">
    <ref name="MSK_ON"/>
    <ref name="MSK_OFF"/>
   </values_from>
   <default>MSK_OFF</default>
  </p>
  <p name="MSK_IPAR_INFEAS_REPORT_LEVEL" val="15">
   <cmnt>Controls the amount of information presented in an infeasibility report.
Higher values imply more information.</cmnt>
   <lower_bound>0</lower_bound>
   <upper_bound>+inf</upper_bound>
   <default>1</default>
  </p>
  <p name="MSK_IPAR_INFEAS_GENERIC_NAMES" val="12">
   <cmnt>Controls whether generic names are used when an infeasible subproblem is created.</cmnt>
   <values_from group="MSKonoffkeye">
    <ref name="MSK_ON"/>
    <ref name="MSK_OFF"/>
   </values_from>
   <default>MSK_OFF</default>
  </p>
  <p name="MSK_IPAR_LOG_INFEAS_ANA" val="46">
   <cmnt>Controls amount of output printed by the infeasibility analyzer procedures. A higher level implies that more information is logged.</cmnt>
   <lower_bound>0</lower_bound>
   <upper_bound>+inf</upper_bound>
   <default>1</default>
  </p>
  <p name="MSK_IPAR_LICENSE_WAIT" val="35">
   <cmnt>If all licenses are in use |mosek| returns with an error code.
However, by turning on this parameter |mosek| will wait for an available license.</cmnt>
   <values_from group="MSKonoffkeye">
    <ref name="MSK_ON"/>
    <ref name="MSK_OFF"/>
   </values_from>
   <default>MSK_OFF</default>
  </p>
  <p name="MSK_IPAR_LICENSE_SUPPRESS_EXPIRE_WRNS" val="33">
   <cmnt>Controls whether license features expire warnings are suppressed.</cmnt>
   <values_from group="MSKonoffkeye">
    <ref name="MSK_ON"/>
    <ref name="MSK_OFF"/>
   </values_from>
   <default>MSK_OFF</default>
  </p>
  <p name="MSK_IPAR_LICENSE_PAUSE_TIME" val="32">
   <cmnt>If :msk:iparam:`license_wait` is :msk:const:`onoffkey.on` and no license is available, then |mosek| sleeps a number
of milliseconds between each check of whether a license has become free.</cmnt>
   <lower_bound>0</lower_bound>
   <upper_bound>1000000</upper_bound>
   <default>100</default>
  </p>
  <p name="MSK_IPAR_LICENSE_DEBUG" val="31">
   <cmnt>This option is used to turn on debugging of the license manager.</cmnt>
   <values_from group="MSKonoffkeye">
    <ref name="MSK_ON"/>
    <ref name="MSK_OFF"/>
   </values_from>
   <default>MSK_OFF</default>
  </p>
  <p name="MSK_IPAR_SOL_FILTER_KEEP_BASIC" val="147">
   <cmnt>If turned on, then basic and super basic constraints and variables
are written to the solution file independent of the filter setting.</cmnt>
   <values_from group="MSKonoffkeye">
    <ref name="MSK_ON"/>
    <ref name="MSK_OFF"/>
   </values_from>
   <default>MSK_OFF</default>
  </p>
  <p name="MSK_IPAR_SOL_FILTER_KEEP_RANGED" val="148">
   <cmnt>If turned on, then ranged constraints and variables are written to the solution file
independent of the filter setting.</cmnt>
   <values_from group="MSKonoffkeye">
    <ref name="MSK_ON"/>
    <ref name="MSK_OFF"/>
   </values_from>
   <default>MSK_OFF</default>
  </p>
  <p name="MSK_IPAR_LOG" val="36">
   <cmnt>Controls the amount of log information. The value 0 implies that all log information is suppressed. A higher level implies that more information is logged.

Please note that if a task is employed to solve a sequence of optimization problems the value of this parameter is reduced by the value of :msk:iparam:`log_cut_second_opt` for the second and any subsequent optimizations.</cmnt>
   <lower_bound>0</lower_bound>
   <upper_bound>+inf</upper_bound>
   <default>10</default>
   <seealso key="MSK_IPAR_LOG_CUT_SECOND_OPT"/>
  </p>
  <p name="MSK_IPAR_LOG_EXPAND" val="42">
   <cmnt>Controls the amount of logging when a data item such as the maximum number constrains is expanded.</cmnt>
   <lower_bound>0</lower_bound>
   <upper_bound>+inf</upper_bound>
   <default>0</default>
  </p>
  <p name="MSK_IPAR_LOG_FILE" val="44">
   <cmnt>If turned on, then some log info is printed when a file is written or read.</cmnt>
   <lower_bound>0</lower_bound>
   <upper_bound>+inf</upper_bound>
   <default>1</default>
  </p>
  <p name="MSK_IPAR_LOG_ORDER" val="51">
   <cmnt>If turned on, then factor lines are added to the log.</cmnt>
   <lower_bound>0</lower_bound>
   <upper_bound>+inf</upper_bound>
   <default>1</default>
  </p>
  <p name="MSK_IPAR_LOG_SENSITIVITY" val="54">
   <cmnt>Controls the amount of logging during the sensitivity analysis.

* :math:`0`. Means no logging information is produced.
* :math:`1`. Timing information is printed.
* :math:`2`. Sensitivity results are printed.</cmnt>
   <lower_bound>0</lower_bound>
   <upper_bound>+inf</upper_bound>
   <default>1</default>
  </p>
  <p name="MSK_IPAR_LOG_SENSITIVITY_OPT" val="55">
   <cmnt>Controls the amount of logging from the optimizers employed during the sensitivity analysis.
0 means no logging information is produced.</cmnt>
   <lower_bound>0</lower_bound>
   <upper_bound>+inf</upper_bound>
   <default>0</default>
  </p>
  <p name="MSK_IPAR_READ_TASK_IGNORE_PARAM" val="117">
   <cmnt>Controls whether |mosek| should ignore the parameter setting defined in the task file and use the default parameter setting instead.</cmnt>
   <values_from group="MSKonoffkeye">
    <ref name="MSK_ON"/>
    <ref name="MSK_OFF"/>
   </values_from>
   <default>MSK_OFF</default>
  </p>
  <p name="MSK_IPAR_WRITE_TASK_INC_SOL" val="178">
   <cmnt>Controls whether the solutions are stored in the task file too.</cmnt>
   <values_from group="MSKonoffkeye">
    <ref name="MSK_ON"/>
    <ref name="MSK_OFF"/>
   </values_from>
   <default>MSK_ON</default>
  </p>
  <p name="MSK_IPAR_PARAM_READ_CASE_NAME" val="98">
   <cmnt>If turned on, then names in the parameter file are case sensitive.</cmnt>
   <values_from group="MSKonoffkeye">
    <ref name="MSK_ON"/>
    <ref name="MSK_OFF"/>
   </values_from>
   <default>MSK_ON</default>
  </p>
  <p name="MSK_IPAR_PARAM_READ_IGN_ERROR" val="99">
   <cmnt>If turned on, then errors in parameter settings is ignored.</cmnt>
   <values_from group="MSKonoffkeye">
    <ref name="MSK_ON"/>
    <ref name="MSK_OFF"/>
   </values_from>
   <default>MSK_OFF</default>
  </p>
  <p name="MSK_IPAR_SOLUTION_CALLBACK" val="151">
   <cmnt>Indicates whether solution callbacks will be performed during the optimization.</cmnt>
   <values_from group="MSKonoffkeye">
    <ref name="MSK_ON"/>
    <ref name="MSK_OFF"/>
   </values_from>
   <default>MSK_OFF</default>
  </p>
  <p name="MSK_IPAR_SIM_SCALING" val="141">
   <cmnt>Controls how much effort is used in scaling the problem before a simplex optimizer is used.</cmnt>
   <values_from group="MSKscalingtypee">
    <ref name="MSK_SCALING_FREE"/>
    <ref name="MSK_SCALING_NONE"/>
    <ref name="MSK_SCALING_MODERATE"/>
    <ref name="MSK_SCALING_AGGRESSIVE"/>
   </values_from>
   <default>MSK_SCALING_FREE</default>
  </p>
  <p name="MSK_IPAR_SIM_SCALING_METHOD" val="142">
   <cmnt>Controls how the problem is scaled before a simplex optimizer is used.</cmnt>
   <values_from group="MSKscalingmethode">
    <ref name="MSK_SCALING_METHOD_POW2"/>
    <ref name="MSK_SCALING_METHOD_FREE"/>
   </values_from>
   <default>MSK_SCALING_METHOD_POW2</default>
  </p>
  <p name="MSK_IPAR_SIM_PRIMAL_PHASEONE_METHOD" val="135">
   <cmnt>An experimental feature.</cmnt>
   <lower_bound>0</lower_bound>
   <upper_bound>10</upper_bound>
   <default>0</default>
  </p>
  <p name="MSK_IPAR_SIM_DUAL_PHASEONE_METHOD" val="125">
   <cmnt>An experimental feature.</cmnt>
   <lower_bound>0</lower_bound>
   <upper_bound>10</upper_bound>
   <default>0</default>
  </p>
  <p name="MSK_IPAR_SIM_MAX_NUM_SETBACKS" val="132">
   <cmnt>Controls how many set-backs are allowed within a simplex
optimizer. A set-back is an event where the optimizer moves in
the wrong direction. This is impossible in theory but may happen due
to numerical problems.</cmnt>
   <lower_bound>0</lower_bound>
   <upper_bound>+inf</upper_bound>
   <default>250</default>
  </p>
  <p name="MSK_IPAR_SIM_HOTSTART" val="129">
   <cmnt>Controls the type of hot-start that the simplex optimizer perform.</cmnt>
   <values_from group="MSKsimhotstarte">
    <ref name="MSK_SIM_HOTSTART_NONE"/>
    <ref name="MSK_SIM_HOTSTART_FREE"/>
    <ref name="MSK_SIM_HOTSTART_STATUS_KEYS"/>
   </values_from>
   <default>MSK_SIM_HOTSTART_FREE</default>
  </p>
  <p name="MSK_IPAR_SIM_BASIS_FACTOR_USE" val="122">
   <cmnt>Controls whether an LU factorization of the basis is used in a hot-start. Forcing a refactorization sometimes improves the stability of the simplex optimizers, but in most cases there is a performance penalty.</cmnt>
   <values_from group="MSKonoffkeye">
    <ref name="MSK_ON"/>
    <ref name="MSK_OFF"/>
   </values_from>
   <default>MSK_ON</default>
  </p>
  <p name="MSK_IPAR_SIM_DEGEN" val="123">
   <cmnt>Controls how aggressively degeneration is handled.</cmnt>
   <values_from group="MSKsimdegene">
    <ref name="MSK_SIM_DEGEN_NONE"/>
    <ref name="MSK_SIM_DEGEN_FREE"/>
    <ref name="MSK_SIM_DEGEN_AGGRESSIVE"/>
    <ref name="MSK_SIM_DEGEN_MODERATE"/>
    <ref name="MSK_SIM_DEGEN_MINIMUM"/>
   </values_from>
   <default>MSK_SIM_DEGEN_FREE</default>
  </p>
  <p name="MSK_IPAR_SIM_REFORMULATION" val="139">
   <cmnt>Controls if the simplex optimizers are allowed to reformulate the problem.</cmnt>
   <values_from group="MSKsimreforme">
    <ref name="MSK_SIM_REFORMULATION_ON"/>
    <ref name="MSK_SIM_REFORMULATION_OFF"/>
    <ref name="MSK_SIM_REFORMULATION_FREE"/>
    <ref name="MSK_SIM_REFORMULATION_AGGRESSIVE"/>
   </values_from>
   <default>MSK_SIM_REFORMULATION_OFF</default>
  </p>
  <p name="MSK_IPAR_SIM_EXPLOIT_DUPVEC" val="128">
   <cmnt>Controls if the simplex optimizers are allowed to exploit duplicated columns.</cmnt>
   <values_from group="MSKsimdupvece">
    <ref name="MSK_SIM_EXPLOIT_DUPVEC_ON"/>
    <ref name="MSK_SIM_EXPLOIT_DUPVEC_OFF"/>
    <ref name="MSK_SIM_EXPLOIT_DUPVEC_FREE"/>
   </values_from>
   <default>MSK_SIM_EXPLOIT_DUPVEC_OFF</default>
  </p>
  <p name="MSK_IPAR_SIM_SAVE_LU" val="140">
   <cmnt>Controls if the LU factorization stored should be replaced with the LU factorization corresponding to the initial basis.</cmnt>
   <values_from group="MSKonoffkeye">
    <ref name="MSK_ON"/>
    <ref name="MSK_OFF"/>
   </values_from>
   <default>MSK_OFF</default>
  </p>
  <p name="MSK_IPAR_SIM_NON_SINGULAR" val="133">
   <cmnt>Controls if the simplex optimizer ensures a non-singular basis, if possible.</cmnt>
   <values_from group="MSKonoffkeye">
    <ref name="MSK_ON"/>
    <ref name="MSK_OFF"/>
   </values_from>
   <default>MSK_ON</default>
  </p>
  <p name="MSK_IPAR_SIM_DUAL_CRASH" val="124">
   <cmnt>Controls whether crashing is performed in the dual simplex optimizer. If this parameter is set to :math:`x`, then a crash will be performed if a basis consists of more than :math:`(100-x)\mod f_v` entries, where :math:`f_v` is the number of fixed variables.</cmnt>
   <lower_bound>0</lower_bound>
   <upper_bound>+inf</upper_bound>
   <default>90</default>
  </p>
  <p name="MSK_IPAR_LOG_STORAGE" val="59">
   <cmnt>When turned on, |mosek| prints messages regarding the storage usage and allocation.</cmnt>
   <lower_bound>0</lower_bound>
   <upper_bound>+inf</upper_bound>
   <default>0</default>
  </p>
  <p name="MSK_IPAR_INFEAS_PREFER_PRIMAL" val="13">
   <cmnt>If both certificates of primal and dual infeasibility are supplied then
only the primal is used when this option is turned on.</cmnt>
   <values_from group="MSKonoffkeye">
    <ref name="MSK_ON"/>
    <ref name="MSK_OFF"/>
   </values_from>
   <default>MSK_ON</default>
  </p>
  <p name="MSK_IPAR_READ_LP_DROP_NEW_VARS_IN_BOU" val="113">
   <cmnt>If this option is turned on, |mosek| will drop variables that are defined for the
first time in the bounds section.</cmnt>
   <values_from group="MSKonoffkeye">
    <ref name="MSK_ON"/>
    <ref name="MSK_OFF"/>
   </values_from>
   <default>MSK_OFF</default>
  </p>
  <p name="MSK_IPAR_OPF_WRITE_LINE_LENGTH" val="90">
   <cmnt>Aim to keep lines in OPF files not much longer than this.</cmnt>
   <lower_bound>0</lower_bound>
   <upper_bound>+inf</upper_bound>
   <default>80</default>
  </p>
  <p name="MSK_IPAR_OPF_WRITE_HINTS" val="89">
   <cmnt>Write a hint section with problem dimensions in the beginning of an OPF file.</cmnt>
   <values_from group="MSKonoffkeye">
    <ref name="MSK_ON"/>
    <ref name="MSK_OFF"/>
   </values_from>
   <default>MSK_ON</default>
  </p>
  <p name="MSK_IPAR_OPF_WRITE_PARAMETERS" val="91">
   <cmnt>Write a parameter section in an OPF file.</cmnt>
   <values_from group="MSKonoffkeye">
    <ref name="MSK_ON"/>
    <ref name="MSK_OFF"/>
   </values_from>
   <default>MSK_OFF</default>
  </p>
  <p name="MSK_IPAR_OPF_WRITE_PROBLEM" val="92">
   <cmnt>Write objective, constraints, bounds etc. to an OPF file.</cmnt>
   <values_from group="MSKonoffkeye">
    <ref name="MSK_ON"/>
    <ref name="MSK_OFF"/>
   </values_from>
   <default>MSK_ON</default>
  </p>
  <p name="MSK_IPAR_OPF_WRITE_HEADER" val="88">
   <cmnt>Write a text header with date and |mosek| version in an OPF file.</cmnt>
   <values_from group="MSKonoffkeye">
    <ref name="MSK_ON"/>
    <ref name="MSK_OFF"/>
   </values_from>
   <default>MSK_ON</default>
  </p>
  <p name="MSK_IPAR_OPF_WRITE_SOLUTIONS" val="96">
   <cmnt>Enable inclusion of solutions in the OPF files.</cmnt>
   <values_from group="MSKonoffkeye">
    <ref name="MSK_ON"/>
    <ref name="MSK_OFF"/>
   </values_from>
   <default>MSK_OFF</default>
  </p>
  <p name="MSK_IPAR_OPF_WRITE_SOL_BAS" val="93">
   <cmnt>If :msk:iparam:`opf_write_solutions` is :msk:const:`onoffkey.on` and a basic solution is defined, include the basic solution in OPF files.</cmnt>
   <values_from group="MSKonoffkeye">
    <ref name="MSK_ON"/>
    <ref name="MSK_OFF"/>
   </values_from>
   <default>MSK_ON</default>
  </p>
  <p name="MSK_IPAR_OPF_WRITE_SOL_ITG" val="94">
   <cmnt>If :msk:iparam:`opf_write_solutions` is :msk:const:`onoffkey.on` and an integer solution is defined, write the integer solution in OPF files.</cmnt>
   <values_from group="MSKonoffkeye">
    <ref name="MSK_ON"/>
    <ref name="MSK_OFF"/>
   </values_from>
   <default>MSK_ON</default>
  </p>
  <p name="MSK_IPAR_OPF_WRITE_SOL_ITR" val="95">
   <cmnt>If :msk:iparam:`opf_write_solutions` is :msk:const:`onoffkey.on` and an interior solution is defined, write the interior  solution in OPF files.</cmnt>
   <values_from group="MSKonoffkeye">
    <ref name="MSK_ON"/>
    <ref name="MSK_OFF"/>
   </values_from>
   <default>MSK_ON</default>
  </p>
  <p name="MSK_IPAR_PTF_WRITE_TRANSFORM" val="110">
   <cmnt>If :msk:iparam:`ptf_write_transform` is
:msk:const:`onoffkey.on`, constraint blocks with
identifiable conic slacks are transformed into conic
constraints and the slacks are eliminated.</cmnt>
   <values_from group="MSKonoffkeye">
    <ref name="MSK_ON"/>
    <ref name="MSK_OFF"/>
   </values_from>
   <default>MSK_ON</default>
  </p>
  <p name="MSK_IPAR_PRIMAL_REPAIR_OPTIMIZER" val="109">
   <cmnt>Controls which optimizer that is used to find the optimal repair.</cmnt>
   <values_from group="MSKoptimizertypee">
    <ref name="MSK_OPTIMIZER_FREE"/>
    <ref name="MSK_OPTIMIZER_INTPNT"/>
    <ref name="MSK_OPTIMIZER_CONIC"/>
    <ref name="MSK_OPTIMIZER_PRIMAL_SIMPLEX"/>
    <ref name="MSK_OPTIMIZER_DUAL_SIMPLEX"/>
    <ref name="MSK_OPTIMIZER_FREE_SIMPLEX"/>
    <ref name="MSK_OPTIMIZER_MIXED_INT"/>
   </values_from>
   <default>MSK_OPTIMIZER_FREE</default>
  </p>
  <p name="MSK_IPAR_MIO_ROOT_REPEAT_PRESOLVE_LEVEL" val="83">
   <cmnt>Controls whether presolve can be repeated at root node.

* :math:`-1`. The optimizer chooses whether presolve is repeated
* :math:`0`. Never repeat presolve
* :math:`1`. Always repeat presolve</cmnt>
   <lower_bound>-1</lower_bound>
   <upper_bound>1</upper_bound>
   <default>-1</default>
  </p>
  <p name="MSK_IPAR_MIO_CUT_CMIR" val="64">
   <cmnt>Controls whether mixed integer rounding cuts should be generated.</cmnt>
   <values_from group="MSKonoffkeye">
    <ref name="MSK_ON"/>
    <ref name="MSK_OFF"/>
   </values_from>
   <default>MSK_ON</default>
  </p>
  <p name="MSK_IPAR_MIO_CUT_CLIQUE" val="63">
   <cmnt>Controls whether clique cuts should be generated.</cmnt>
   <values_from group="MSKonoffkeye">
    <ref name="MSK_ON"/>
    <ref name="MSK_OFF"/>
   </values_from>
   <default>MSK_ON</default>
  </p>
  <p name="MSK_IPAR_MIO_CUT_IMPLIED_BOUND" val="66">
   <cmnt>Controls whether implied bound cuts should be generated.</cmnt>
   <values_from group="MSKonoffkeye">
    <ref name="MSK_ON"/>
    <ref name="MSK_OFF"/>
   </values_from>
   <default>MSK_OFF</default>
  </p>
  <p name="MSK_IPAR_MIO_CUT_KNAPSACK_COVER" val="67">
   <cmnt>Controls whether knapsack cover cuts should be generated.</cmnt>
   <values_from group="MSKonoffkeye">
    <ref name="MSK_ON"/>
    <ref name="MSK_OFF"/>
   </values_from>
   <default>MSK_OFF</default>
  </p>
  <p name="MSK_IPAR_MIO_CUT_GMI" val="65">
   <cmnt>Controls whether GMI cuts should be generated.</cmnt>
   <values_from group="MSKonoffkeye">
    <ref name="MSK_ON"/>
    <ref name="MSK_OFF"/>
   </values_from>
   <default>MSK_ON</default>
  </p>
  <p name="MSK_IPAR_SENSITIVITY_TYPE" val="121">
   <cmnt>Controls which type of sensitivity analysis is to be performed.</cmnt>
   <values_from group="MSKsensitivitytypee">
    <ref name="MSK_SENSITIVITY_TYPE_BASIS"/>
   </values_from>
   <default>MSK_SENSITIVITY_TYPE_BASIS</default>
  </p>
  <p name="MSK_IPAR_PRESOLVE_LINDEP_REL_WORK_TRH" val="104">
   <cmnt>Controls linear dependency check in presolve. The linear dependency check is potentially computationally expensive.</cmnt>
   <lower_bound>-inf</lower_bound>
   <upper_bound>+inf</upper_bound>
   <default>100</default>
  </p>
  <p name="MSK_IPAR_PRESOLVE_LINDEP_ABS_WORK_TRH" val="103">
   <cmnt>Controls linear dependency check in presolve. The linear dependency check is potentially computationally expensive.</cmnt>
   <lower_bound>-inf</lower_bound>
   <upper_bound>+inf</upper_bound>
   <default>100</default>
  </p>
  <p name="MSK_IPAR_SENSITIVITY_ALL" val="119">
   <cmnt>.. msk_only:: not optimizer

   Not applicable.

.. msk_only:: optimizer

   If set to :msk:const:`onoffkey.on`, then :msk:func:`task.sensitivityreport` analyzes all
   bounds and variables instead of reading a specification from the file.</cmnt>
   <values_from group="MSKonoffkeye">
    <ref name="MSK_ON"/>
    <ref name="MSK_OFF"/>
   </values_from>
   <default>MSK_OFF</default>
  </p>
  <p name="MSK_IPAR_LOG_FEAS_REPAIR" val="43">
   <cmnt>Controls the amount of output printed when performing feasibility repair. A value higher than one means extensive logging.</cmnt>
   <lower_bound>0</lower_bound>
   <upper_bound>+inf</upper_bound>
   <default>1</default>
  </p>
  <p name="MSK_IPAR_CACHE_LICENSE" val="9">
   <cmnt>Specifies if the license is kept checked out for the
lifetime of the |mosek| environment/model/process (:msk:const:`onoffkey.on`) or
returned to the server immediately after the
optimization (:msk:const:`onoffkey.off`).

.. msk_only:: optimizer

   By default the license is checked out for the lifetime of the |mosek| environment by the first call to :msk:func:`task.optimize`.

.. msk_only:: fusion

   By default the license is checked out for the lifetime of the process by the first call to :msk:func:`model.solve`.

.. msk_only:: matlab or rmosek

   By default the license is checked out for the lifetime of the session at the start of first optimization.

Check-in and check-out of licenses have an
overhead. Frequent communication with the license
server should be avoided.</cmnt>
   <values_from group="MSKonoffkeye">
    <ref name="MSK_ON"/>
    <ref name="MSK_OFF"/>
   </values_from>
   <default>MSK_ON</default>
  </p>
  <p name="MSK_IPAR_INTPNT_REGULARIZATION_USE" val="27">
   <cmnt>Controls whether regularization is allowed.</cmnt>
   <values_from group="MSKonoffkeye">
    <ref name="MSK_ON"/>
    <ref name="MSK_OFF"/>
   </values_from>
   <default>MSK_ON</default>
  </p>
  <p name="MSK_IPAR_SIM_SOLVE_FORM" val="144">
   <cmnt>Controls whether the primal or the dual problem is solved by the primal-/dual-simplex optimizer.</cmnt>
   <values_from group="MSKsolveforme">
    <ref name="MSK_SOLVE_FREE"/>
    <ref name="MSK_SOLVE_PRIMAL"/>
    <ref name="MSK_SOLVE_DUAL"/>
   </values_from>
   <default>MSK_SOLVE_FREE</default>
  </p>
  <p name="MSK_IPAR_SIM_SWITCH_OPTIMIZER" val="146">
   <cmnt>The simplex optimizer sometimes chooses to solve the dual problem instead of the primal problem.
This implies that if you have chosen to use the dual simplex optimizer and the problem is dualized,
then it actually makes sense to use the primal simplex optimizer instead. If this parameter is on
and the problem is dualized and furthermore the simplex optimizer is chosen to be the primal (dual) one,
then it is switched to the dual (primal).</cmnt>
   <values_from group="MSKonoffkeye">
    <ref name="MSK_ON"/>
    <ref name="MSK_OFF"/>
   </values_from>
   <default>MSK_OFF</default>
  </p>
  <p name="MSK_IPAR_WRITE_IGNORE_INCOMPATIBLE_ITEMS" val="161">
   <cmnt>Controls if the writer ignores incompatible problem items when writing files.</cmnt>
   <values_from group="MSKonoffkeye">
    <ref name="MSK_ON">Ignore items that cannot be written to the current output file format.</ref>
    <ref name="MSK_OFF">Produce an error if the problem contains items that cannot the written to the current output file format.</ref>
   </values_from>
   <default>MSK_OFF</default>
  </p>
  <p name="MSK_IPAR_CHECK_CONVEXITY" val="10">
   <cmnt>Specify the level of convexity check on quadratic problems.</cmnt>
   <values_from group="MSKcheckconvexitytypee">
    <ref name="MSK_CHECK_CONVEXITY_NONE"/>
    <ref name="MSK_CHECK_CONVEXITY_SIMPLE"/>
    <ref name="MSK_CHECK_CONVEXITY_FULL"/>
   </values_from>
   <default>MSK_CHECK_CONVEXITY_FULL</default>
  </p>
  <p name="MSK_IPAR_LOG_CHECK_CONVEXITY" val="40">
   <cmnt>Controls logging in convexity check on quadratic problems. Set to a positive value to turn logging on. If a quadratic coefficient matrix is found to violate the requirement of PSD (NSD) then a list of negative (positive) pivot elements is printed. The absolute value of the pivot elements is also shown.</cmnt>
   <lower_bound>0</lower_bound>
   <upper_bound>+inf</upper_bound>
   <default>0</default>
  </p>
  <p name="MSK_IPAR_AUTO_SORT_A_BEFORE_OPT" val="2">
   <cmnt>Controls whether the elements in each column of :math:`A` are sorted before an optimization is performed.
This is not required but makes the optimization more deterministic.</cmnt>
   <values_from group="MSKonoffkeye">
    <ref name="MSK_ON"/>
    <ref name="MSK_OFF"/>
   </values_from>
   <default>MSK_OFF</default>
  </p>
  <p name="MSK_IPAR_SENSITIVITY_OPTIMIZER" val="120">
   <cmnt>Controls which optimizer is used for optimal partition sensitivity analysis.</cmnt>
   <values_from group="MSKoptimizertypee">
    <ref name="MSK_OPTIMIZER_FREE"/>
    <ref name="MSK_OPTIMIZER_INTPNT"/>
    <ref name="MSK_OPTIMIZER_CONIC"/>
    <ref name="MSK_OPTIMIZER_PRIMAL_SIMPLEX"/>
    <ref name="MSK_OPTIMIZER_DUAL_SIMPLEX"/>
    <ref name="MSK_OPTIMIZER_FREE_SIMPLEX"/>
    <ref name="MSK_OPTIMIZER_MIXED_INT"/>
   </values_from>
   <default>MSK_OPTIMIZER_FREE_SIMPLEX</default>
  </p>
  <p name="MSK_IPAR_WRITE_XML_MODE" val="179">
   <cmnt>Controls if linear coefficients should be written by row or column when writing in the XML file format.</cmnt>
   <values_from group="MSKxmlwriteroutputtypee">
    <ref name="MSK_WRITE_XML_MODE_ROW"/>
    <ref name="MSK_WRITE_XML_MODE_COL"/>
   </values_from>
   <default>MSK_WRITE_XML_MODE_ROW</default>
  </p>
  <p name="MSK_IPAR_ANA_SOL_BASIS" val="0">
   <cmnt>Controls whether the basis matrix is analyzed in solution analyzer.</cmnt>
   <values_from group="MSKonoffkeye">
    <ref name="MSK_ON"/>
    <ref name="MSK_OFF"/>
   </values_from>
   <default>MSK_ON</default>
  </p>
  <p name="MSK_IPAR_ANA_SOL_PRINT_VIOLATED" val="1">
   <cmnt>A parameter of the problem analyzer. Controls whether a list of violated constraints is printed. All constraints violated by more than the value set by the parameter :msk:dparam:`ana_sol_infeas_tol` will be printed.</cmnt>
   <values_from group="MSKonoffkeye">
    <ref name="MSK_ON"/>
    <ref name="MSK_OFF"/>
   </values_from>
   <default>MSK_OFF</default>
  </p>
  <p name="MSK_IPAR_BASIS_SOLVE_USE_PLUS_ONE" val="4">
   <cmnt>If a slack variable is in the basis, then the corresponding column in the basis is a unit vector
with -1 in the right position. However, if this parameter is set to :msk:const:`onoffkey.on`, -1 is replaced by 1.

.. msk_only:: optimizer

   This has significance for the results returned by the :msk:func:`task.solvewithbasis` function.</cmnt>
   <values_from group="MSKonoffkeye">
    <ref name="MSK_ON"/>
    <ref name="MSK_OFF"/>
   </values_from>
   <default>MSK_OFF</default>
  </p>
  <p name="MSK_IPAR_COMPRESS_STATFILE" val="11">
   <cmnt>Control compression of stat files.</cmnt>
   <values_from group="MSKonoffkeye">
    <ref name="MSK_ON"/>
    <ref name="MSK_OFF"/>
   </values_from>
   <default>MSK_on</default>
  </p>
  <p name="MSK_IPAR_MIO_RINS_MAX_NODES" val="81">
   <cmnt>Controls the maximum number of nodes allowed in each call to the RINS heuristic. The default value of -1
means that the value is determined automatically. A value of zero turns off the heuristic.</cmnt>
   <lower_bound>-1</lower_bound>
   <upper_bound>+inf</upper_bound>
   <default>-1</default>
  </p>
  <p name="MSK_IPAR_MIO_FEASPUMP_LEVEL" val="69">
   <cmnt>Controls the way the Feasibility Pump heuristic is employed by the mixed-integer optimizer.

* :math:`-1`. The optimizer chooses how the Feasibility Pump is used
* :math:`0`. The Feasibility Pump is disabled
* :math:`1`. The Feasibility Pump is enabled with an effort to improve solution quality
* :math:`2`. The Feasibility Pump is enabled with an effort to reach feasibility early</cmnt>
   <lower_bound>-1</lower_bound>
   <upper_bound>2</upper_bound>
   <default>-1</default>
  </p>
 </sec>
 <sec id="MSKbranchdire" type="constants">
  <cmnt>Specifies the branching direction.</cmnt>
  <c name="MSK_BRANCH_DIR_FREE" val="0">
   <cmnt>The mixed-integer optimizer decides which branch to choose.</cmnt>
  </c>
  <c name="MSK_BRANCH_DIR_UP" val="1">
   <cmnt>The mixed-integer optimizer always chooses the up branch first.</cmnt>
  </c>
  <c name="MSK_BRANCH_DIR_DOWN" val="2">
   <cmnt>The mixed-integer optimizer always chooses the down branch first.</cmnt>
  </c>
  <c name="MSK_BRANCH_DIR_NEAR" val="3">
   <cmnt>Branch in direction nearest to selected fractional variable.</cmnt>
  </c>
  <c name="MSK_BRANCH_DIR_FAR" val="4">
   <cmnt>Branch in direction farthest from selected fractional variable.</cmnt>
  </c>
  <c name="MSK_BRANCH_DIR_ROOT_LP" val="5">
   <cmnt>Chose direction based on root lp value of selected variable.</cmnt>
  </c>
  <c name="MSK_BRANCH_DIR_GUIDED" val="6">
   <cmnt>Branch in direction of current incumbent.</cmnt>
  </c>
  <c name="MSK_BRANCH_DIR_PSEUDOCOST" val="7">
   <cmnt>Branch based on the pseudocost of the variable.</cmnt>
  </c>
 </sec>
 <sec id="MSKmiocontsoltypee" type="constants">
  <cmnt>Continuous mixed-integer solution type</cmnt>
  <c name="MSK_MIO_CONT_SOL_NONE" val="0">
   <cmnt>No interior-point or basic solution are reported when the mixed-integer optimizer is used.</cmnt>
  </c>
  <c name="MSK_MIO_CONT_SOL_ROOT" val="1">
   <cmnt>The reported interior-point and basic solutions are a solution to the root node problem when mixed-integer optimizer is used.</cmnt>
  </c>
  <c name="MSK_MIO_CONT_SOL_ITG" val="2">
   <cmnt>The reported interior-point and basic solutions are a solution to the problem with all integer variables fixed at the value they have in the integer solution. A solution is only reported in case the problem has a primal feasible solution.</cmnt>
  </c>
  <c name="MSK_MIO_CONT_SOL_ITG_REL" val="3">
   <cmnt>In case the problem is primal feasible then the reported interior-point and basic solutions are a solution to the problem with all integer variables fixed at the value they have in the integer solution. If the problem is primal infeasible, then the solution to the root node problem is reported.</cmnt>
  </c>
 </sec>
 <sec id="MSKmiomodee" type="constants">
  <cmnt>Integer restrictions</cmnt>
  <c name="MSK_MIO_MODE_IGNORED" val="0">
   <cmnt>The integer constraints are ignored and the problem is solved as a continuous problem.</cmnt>
  </c>
  <c name="MSK_MIO_MODE_SATISFIED" val="1">
   <cmnt>Integer restrictions should be satisfied.</cmnt>
  </c>
 </sec>
 <sec id="MSKmionodeseltypee" type="constants">
  <cmnt>Mixed-integer node selection types</cmnt>
  <c name="MSK_MIO_NODE_SELECTION_FREE" val="0">
   <cmnt>The optimizer decides the node selection strategy.</cmnt>
  </c>
  <c name="MSK_MIO_NODE_SELECTION_FIRST" val="1">
   <cmnt>The optimizer employs a depth first node selection strategy.</cmnt>
  </c>
  <c name="MSK_MIO_NODE_SELECTION_BEST" val="2">
   <cmnt>The optimizer employs a best bound node selection strategy.</cmnt>
  </c>
  <c name="MSK_MIO_NODE_SELECTION_PSEUDO" val="3">
   <cmnt>The optimizer employs selects the node based on a pseudo cost estimate.</cmnt>
  </c>
 </sec>
 <sec id="MSKmpsformate" type="constants">
  <cmnt>MPS file format type</cmnt>
  <c name="MSK_MPS_FORMAT_STRICT" val="0">
   <cmnt>It is assumed that the input file satisfies the MPS format strictly.</cmnt>
  </c>
  <c name="MSK_MPS_FORMAT_RELAXED" val="1">
   <cmnt>It is assumed that the input file satisfies a slightly relaxed version of the MPS format.</cmnt>
  </c>
  <c name="MSK_MPS_FORMAT_FREE" val="2">
   <cmnt>It is assumed that the input file satisfies the free MPS format. This implies that spaces are not allowed in names. Otherwise the format is free.</cmnt>
  </c>
  <c name="MSK_MPS_FORMAT_CPLEX" val="3">
   <cmnt>The CPLEX compatible version of the MPS format is employed.</cmnt>
  </c>
 </sec>
 <sec id="MSKobjsensee" type="enum">
  <cmnt>Objective sense types</cmnt>
  <c name="MSK_OBJECTIVE_SENSE_MINIMIZE" val="0">
   <cmnt>The problem should be minimized.</cmnt>
  </c>
  <c name="MSK_OBJECTIVE_SENSE_MAXIMIZE" val="1">
   <cmnt>The problem should be maximized.</cmnt>
  </c>
 </sec>
 <sec id="MSKonoffkeye" type="constants">
  <cmnt>On/off</cmnt>
  <c name="MSK_ON" val="1">
   <cmnt>Switch the option on.</cmnt>
  </c>
  <c name="MSK_OFF" val="0">
   <cmnt>Switch the option off.</cmnt>
  </c>
 </sec>
 <sec id="MSKoptimizertypee" type="constants">
  <cmnt>Optimizer types</cmnt>
  <c name="MSK_OPTIMIZER_FREE" val="2">
   <cmnt>The optimizer is chosen automatically.</cmnt>
  </c>
  <c name="MSK_OPTIMIZER_INTPNT" val="4">
   <cmnt>The interior-point optimizer is used.</cmnt>
  </c>
  <c name="MSK_OPTIMIZER_CONIC" val="0">
   <cmnt>The optimizer for problems having conic constraints.</cmnt>
  </c>
  <c name="MSK_OPTIMIZER_PRIMAL_SIMPLEX" val="6">
   <cmnt>The primal simplex optimizer is used.</cmnt>
  </c>
  <c name="MSK_OPTIMIZER_DUAL_SIMPLEX" val="1">
   <cmnt>The dual simplex optimizer is used.</cmnt>
  </c>
  <c name="MSK_OPTIMIZER_FREE_SIMPLEX" val="3">
   <cmnt>One of the simplex optimizers is used.</cmnt>
  </c>
  <c name="MSK_OPTIMIZER_MIXED_INT" val="5">
   <cmnt>The mixed-integer optimizer.</cmnt>
  </c>
 </sec>
 <sec id="MSKorderingtypee" type="constants">
  <cmnt>Ordering strategies</cmnt>
  <c name="MSK_ORDER_METHOD_FREE" val="0">
   <cmnt>The ordering method is chosen automatically.</cmnt>
  </c>
  <c name="MSK_ORDER_METHOD_APPMINLOC" val="1">
   <cmnt>Approximate minimum local fill-in ordering is employed.</cmnt>
  </c>
  <c name="MSK_ORDER_METHOD_EXPERIMENTAL" val="2">
   <cmnt>This option should not be used.</cmnt>
  </c>
  <c name="MSK_ORDER_METHOD_TRY_GRAPHPAR" val="3">
   <cmnt>Always try the graph partitioning based ordering.</cmnt>
  </c>
  <c name="MSK_ORDER_METHOD_FORCE_GRAPHPAR" val="4">
   <cmnt>Always use the graph partitioning based ordering even if it is worse than the approximate minimum local fill ordering.</cmnt>
  </c>
  <c name="MSK_ORDER_METHOD_NONE" val="5">
   <cmnt>No ordering is used.</cmnt>
  </c>
 </sec>
 <sec id="MSKpresolvemodee" type="constants">
  <cmnt>Presolve method.</cmnt>
  <c name="MSK_PRESOLVE_MODE_OFF" val="0">
   <cmnt>The problem is not presolved before it is optimized.</cmnt>
  </c>
  <c name="MSK_PRESOLVE_MODE_ON" val="1">
   <cmnt>The problem is presolved before it is optimized.</cmnt>
  </c>
  <c name="MSK_PRESOLVE_MODE_FREE" val="2">
   <cmnt>It is decided automatically whether to presolve before the problem is optimized.</cmnt>
  </c>
 </sec>
 <sec id="MSKparametertypee" type="enum">
  <cmnt>Parameter type</cmnt>
  <c name="MSK_PAR_INVALID_TYPE" val="0">
   <cmnt>Not a valid parameter.</cmnt>
  </c>
  <c name="MSK_PAR_DOU_TYPE" val="1">
   <cmnt>Is a double parameter.</cmnt>
  </c>
  <c name="MSK_PAR_INT_TYPE" val="2">
   <cmnt>Is an integer parameter.</cmnt>
  </c>
  <c name="MSK_PAR_STR_TYPE" val="3">
   <cmnt>Is a string parameter.</cmnt>
  </c>
 </sec>
 <sec id="MSKproblemiteme" type="enum">
  <cmnt>Problem data items</cmnt>
  <c name="MSK_PI_VAR" val="0">
   <cmnt>Item is a variable.</cmnt>
  </c>
  <c name="MSK_PI_CON" val="1">
   <cmnt>Item is a constraint.</cmnt>
  </c>
  <c name="MSK_PI_CONE" val="2">
   <cmnt>Item is a cone.</cmnt>
  </c>
 </sec>
 <sec id="MSKproblemtypee" type="enum">
  <cmnt>Problem types</cmnt>
  <c name="MSK_PROBTYPE_LO" val="0">
   <cmnt>The problem is a linear optimization problem.</cmnt>
  </c>
  <c name="MSK_PROBTYPE_QO" val="1">
   <cmnt>The problem is a quadratic optimization problem.</cmnt>
  </c>
  <c name="MSK_PROBTYPE_QCQO" val="2">
   <cmnt>The problem is a quadratically constrained optimization problem.</cmnt>
  </c>
  <c name="MSK_PROBTYPE_CONIC" val="3">
   <cmnt>A conic optimization.</cmnt>
  </c>
  <c name="MSK_PROBTYPE_MIXED" val="4">
   <cmnt>General nonlinear constraints and conic constraints. This combination can not be solved by |mosek|.</cmnt>
  </c>
 </sec>
 <sec id="MSKprostae" type="enum">
  <cmnt>Problem status keys</cmnt>
  <c name="MSK_PRO_STA_UNKNOWN" val="0">
   <cmnt>Unknown problem status.</cmnt>
  </c>
  <c name="MSK_PRO_STA_PRIM_AND_DUAL_FEAS" val="1">
   <cmnt>The problem is primal and dual feasible.</cmnt>
  </c>
  <c name="MSK_PRO_STA_PRIM_FEAS" val="2">
   <cmnt>The problem is primal feasible.</cmnt>
  </c>
  <c name="MSK_PRO_STA_DUAL_FEAS" val="3">
   <cmnt>The problem is dual feasible.</cmnt>
  </c>
  <c name="MSK_PRO_STA_PRIM_INFEAS" val="4">
   <cmnt>The problem is primal infeasible.</cmnt>
  </c>
  <c name="MSK_PRO_STA_DUAL_INFEAS" val="5">
   <cmnt>The problem is dual infeasible.</cmnt>
  </c>
  <c name="MSK_PRO_STA_PRIM_AND_DUAL_INFEAS" val="6">
   <cmnt>The problem is primal and dual infeasible.</cmnt>
  </c>
  <c name="MSK_PRO_STA_ILL_POSED" val="7">
   <cmnt>The problem is ill-posed. For example, it may be primal and dual feasible but have a positive duality gap.</cmnt>
  </c>
  <c name="MSK_PRO_STA_PRIM_INFEAS_OR_UNBOUNDED" val="8">
   <cmnt>The problem is either primal infeasible or unbounded. This may occur for mixed-integer problems.</cmnt>
  </c>
 </sec>
 <sec id="MSKxmlwriteroutputtypee" type="enum">
  <cmnt>XML writer output mode</cmnt>
  <c name="MSK_WRITE_XML_MODE_ROW" val="0">
   <cmnt>Write in row order.</cmnt>
  </c>
  <c name="MSK_WRITE_XML_MODE_COL" val="1">
   <cmnt>Write in column order.</cmnt>
  </c>
 </sec>
 <sec id="MSKrescodee" type="enum">
  <cmnt>The enumeration type containing all response codes.</cmnt>
  <c name="MSK_RES_OK" val="0">
   <cmnt>No error occurred.</cmnt>
  </c>
  <c name="MSK_RES_WRN_OPEN_PARAM_FILE" val="50">
   <cmnt>The parameter file could not be opened.</cmnt>
  </c>
  <c name="MSK_RES_WRN_LARGE_BOUND" val="51">
   <cmnt>A numerically large bound value is specified.</cmnt>
  </c>
  <c name="MSK_RES_WRN_LARGE_LO_BOUND" val="52">
   <cmnt>A numerically large lower bound value is specified.</cmnt>
  </c>
  <c name="MSK_RES_WRN_LARGE_UP_BOUND" val="53">
   <cmnt>A numerically large upper bound value is specified.</cmnt>
  </c>
  <c name="MSK_RES_WRN_LARGE_CON_FX" val="54">
   <cmnt>An equality constraint is fixed to a numerically large value. This can cause numerical problems.</cmnt>
  </c>
  <c name="MSK_RES_WRN_LARGE_CJ" val="57">
   <cmnt>A numerically large value is specified for one :math:`c_{j}`.</cmnt>
  </c>
  <c name="MSK_RES_WRN_LARGE_AIJ" val="62">
   <cmnt>A numerically large value is specified for an :math:`a_{i,j}` element in :math:`A`.
The parameter :msk:dparam:`data_tol_aij_large` controls when an :math:`a_{i,j}` is considered large.</cmnt>
  </c>
  <c name="MSK_RES_WRN_ZERO_AIJ" val="63">
   <cmnt>One or more zero elements are specified in A.</cmnt>
  </c>
  <c name="MSK_RES_WRN_NAME_MAX_LEN" val="65">
   <cmnt>A name is longer than the buffer that is supposed to hold it.</cmnt>
  </c>
  <c name="MSK_RES_WRN_SPAR_MAX_LEN" val="66">
   <cmnt>A value for a string parameter is longer than the buffer that is supposed to hold it.</cmnt>
  </c>
  <c name="MSK_RES_WRN_MPS_SPLIT_RHS_VECTOR" val="70">
   <cmnt>An RHS vector is split into several nonadjacent parts in an MPS file.</cmnt>
  </c>
  <c name="MSK_RES_WRN_MPS_SPLIT_RAN_VECTOR" val="71">
   <cmnt>A RANGE vector is split into several nonadjacent parts in an MPS file.</cmnt>
  </c>
  <c name="MSK_RES_WRN_MPS_SPLIT_BOU_VECTOR" val="72">
   <cmnt>A BOUNDS vector is split into several nonadjacent parts in an MPS file.</cmnt>
  </c>
  <c name="MSK_RES_WRN_LP_OLD_QUAD_FORMAT" val="80">
   <cmnt>Missing '/2' after quadratic expressions in bound or objective.</cmnt>
  </c>
  <c name="MSK_RES_WRN_LP_DROP_VARIABLE" val="85">
   <cmnt>Ignored a variable because the variable was not previously defined.
Usually this implies that a variable appears in the bound section but not in the objective or the constraints.</cmnt>
  </c>
  <c name="MSK_RES_WRN_NZ_IN_UPR_TRI" val="200">
   <cmnt>Non-zero elements specified in the upper triangle of a matrix were ignored.</cmnt>
  </c>
  <c name="MSK_RES_WRN_DROPPED_NZ_QOBJ" val="201">
   <cmnt>One or more non-zero elements were dropped in the Q matrix in the objective.</cmnt>
  </c>
  <c name="MSK_RES_WRN_IGNORE_INTEGER" val="250">
   <cmnt>Ignored integer constraints.</cmnt>
  </c>
  <c name="MSK_RES_WRN_NO_GLOBAL_OPTIMIZER" val="251">
   <cmnt>No global optimizer is available.</cmnt>
  </c>
  <c name="MSK_RES_WRN_MIO_INFEASIBLE_FINAL" val="270">
   <cmnt>The final mixed-integer problem with all the integer variables fixed at their optimal values is infeasible.</cmnt>
  </c>
  <c name="MSK_RES_WRN_SOL_FILTER" val="300">
   <cmnt>Invalid solution filter is specified.</cmnt>
  </c>
  <c name="MSK_RES_WRN_UNDEF_SOL_FILE_NAME" val="350">
   <cmnt>Undefined name occurred in a solution.</cmnt>
  </c>
  <c name="MSK_RES_WRN_SOL_FILE_IGNORED_CON" val="351">
   <cmnt>One or more lines in the constraint section were ignored when reading a solution file.</cmnt>
  </c>
  <c name="MSK_RES_WRN_SOL_FILE_IGNORED_VAR" val="352">
   <cmnt>One or more lines in the variable section were ignored when reading a solution file.</cmnt>
  </c>
  <c name="MSK_RES_WRN_TOO_FEW_BASIS_VARS" val="400">
   <cmnt>An incomplete basis has been specified. Too few basis variables are specified.</cmnt>
  </c>
  <c name="MSK_RES_WRN_TOO_MANY_BASIS_VARS" val="405">
   <cmnt>A basis with too many variables has been specified.</cmnt>
  </c>
  <c name="MSK_RES_WRN_LICENSE_EXPIRE" val="500">
   <cmnt>The license expires.</cmnt>
  </c>
  <c name="MSK_RES_WRN_LICENSE_SERVER" val="501">
   <cmnt>The license server is not responding.</cmnt>
  </c>
  <c name="MSK_RES_WRN_EMPTY_NAME" val="502">
   <cmnt>A variable or constraint name is empty. The output file may be invalid.</cmnt>
  </c>
  <c name="MSK_RES_WRN_USING_GENERIC_NAMES" val="503">
   <cmnt>Generic names are used because a name is not valid. For instance when writing an LP file the names must not contain blanks or start with a digit.</cmnt>
  </c>
  <c name="MSK_RES_WRN_LICENSE_FEATURE_EXPIRE" val="505">
   <cmnt>The license expires.</cmnt>
  </c>
  <c name="MSK_RES_WRN_PARAM_NAME_DOU" val="510">
   <cmnt>The parameter name is not recognized as a double parameter.</cmnt>
  </c>
  <c name="MSK_RES_WRN_PARAM_NAME_INT" val="511">
   <cmnt>The parameter name is not recognized as a integer parameter.</cmnt>
  </c>
  <c name="MSK_RES_WRN_PARAM_NAME_STR" val="512">
   <cmnt>The parameter name is not recognized as a string parameter.</cmnt>
  </c>
  <c name="MSK_RES_WRN_PARAM_STR_VALUE" val="515">
   <cmnt>The string is not recognized as a symbolic value for the parameter.</cmnt>
  </c>
  <c name="MSK_RES_WRN_PARAM_IGNORED_CMIO" val="516">
   <cmnt>A parameter was ignored by the conic mixed integer optimizer.</cmnt>
  </c>
  <c name="MSK_RES_WRN_ZEROS_IN_SPARSE_ROW" val="705">
   <cmnt>One or more (near) zero elements are specified in a sparse row of a matrix. Since, it
is redundant to specify zero elements then it may indicate an error.</cmnt>
  </c>
  <c name="MSK_RES_WRN_ZEROS_IN_SPARSE_COL" val="710">
   <cmnt>One or more (near) zero elements are specified in a sparse column of a matrix.
It is redundant to specify zero elements. Hence, it may indicate an error.</cmnt>
  </c>
  <c name="MSK_RES_WRN_INCOMPLETE_LINEAR_DEPENDENCY_CHECK" val="800">
   <cmnt>The linear dependency check(s) is incomplete. Normally
this is not an important warning unless the optimization
problem has been formulated with linear
dependencies. Linear dependencies may prevent |mosek| from
solving the problem.</cmnt>
  </c>
  <c name="MSK_RES_WRN_ELIMINATOR_SPACE" val="801">
   <cmnt>The eliminator is skipped at least once due to lack of space.</cmnt>
  </c>
  <c name="MSK_RES_WRN_PRESOLVE_OUTOFSPACE" val="802">
   <cmnt>The presolve is incomplete due to lack of space.</cmnt>
  </c>
  <c name="MSK_RES_WRN_WRITE_CHANGED_NAMES" val="803">
   <cmnt>Some names were changed because they were invalid for the output file format.</cmnt>
  </c>
  <c name="MSK_RES_WRN_WRITE_DISCARDED_CFIX" val="804">
   <cmnt>The fixed objective term could not be converted to a variable and was discarded in the output file.</cmnt>
  </c>
  <c name="MSK_RES_WRN_DUPLICATE_CONSTRAINT_NAMES" val="850">
   <cmnt>Two constraint names are identical.</cmnt>
  </c>
  <c name="MSK_RES_WRN_DUPLICATE_VARIABLE_NAMES" val="851">
   <cmnt>Two variable names are identical.</cmnt>
  </c>
  <c name="MSK_RES_WRN_DUPLICATE_BARVARIABLE_NAMES" val="852">
   <cmnt>Two barvariable names are identical.</cmnt>
  </c>
  <c name="MSK_RES_WRN_DUPLICATE_CONE_NAMES" val="853">
   <cmnt>Two cone names are identical.</cmnt>
  </c>
  <c name="MSK_RES_WRN_ANA_LARGE_BOUNDS" val="900">
   <cmnt>This warning is issued by the problem analyzer, if one or more constraint or variable bounds are very large.
One should consider omitting these bounds entirely by setting them to +inf or -inf.</cmnt>
  </c>
  <c name="MSK_RES_WRN_ANA_C_ZERO" val="901">
   <cmnt>This warning is issued by the problem analyzer, if the coefficients in the linear part of the objective are all zero.</cmnt>
  </c>
  <c name="MSK_RES_WRN_ANA_EMPTY_COLS" val="902">
   <cmnt>This warning is issued by the problem analyzer, if columns, in which all coefficients are zero, are found.</cmnt>
  </c>
  <c name="MSK_RES_WRN_ANA_CLOSE_BOUNDS" val="903">
   <cmnt>This warning is issued by problem analyzer, if ranged
constraints or variables with very close upper and lower
bounds are detected.  One should consider treating such
constraints as equalities and such variables as
constants.</cmnt>
  </c>
  <c name="MSK_RES_WRN_ANA_ALMOST_INT_BOUNDS" val="904">
   <cmnt>This warning is issued by the problem analyzer if a
constraint is bound nearly integral.</cmnt>
  </c>
  <c name="MSK_RES_WRN_QUAD_CONES_WITH_ROOT_FIXED_AT_ZERO" val="930">
   <cmnt>For at least one quadratic cone the root is fixed at (nearly) zero. This may cause problems such as a very large dual solution.
Therefore, it is recommended to remove such cones before optimizing the problem, or to fix all the variables in the cone to 0.</cmnt>
  </c>
  <c name="MSK_RES_WRN_RQUAD_CONES_WITH_ROOT_FIXED_AT_ZERO" val="931">
   <cmnt>For at least one rotated quadratic cone at least one of
the root variables are fixed at (nearly) zero. This may
cause problems such as a very large dual solution.
Therefore, it is recommended to remove such cones before
optimizing the problem, or to fix all the variables in
the cone to 0.</cmnt>
  </c>
  <c name="MSK_RES_WRN_EXP_CONES_WITH_VARIABLES_FIXED_AT_ZERO" val="932">
   <cmnt>For at least one exponential cone :math:`x\geq y\exp(z/y)` either the variable :math:`x` or :math:`y` is fixed at (nearly) zero. This may cause problems such as a very large dual solution.
Therefore, it is recommended to remove such cones before optimizing the problem, or to fix all the variables in the cone to 0.</cmnt>
  </c>
  <c name="MSK_RES_WRN_POW_CONES_WITH_ROOT_FIXED_AT_ZERO" val="933">
   <cmnt>For at least one power cone at least one of
the root variables are fixed at (nearly) zero. This may
cause problems such as a very large dual solution.
Therefore, it is recommended to remove such cones before
optimizing the problem, or to fix all the variables in
the cone to 0.</cmnt>
  </c>
  <c name="MSK_RES_WRN_NO_DUALIZER" val="950">
   <cmnt>No automatic dualizer is available for the specified problem. The primal problem is solved.</cmnt>
  </c>
  <c name="MSK_RES_WRN_SYM_MAT_LARGE" val="960">
   <cmnt>A numerically large value is specified for an :math:`e_{i,j}` element in :math:`E`.
The parameter :msk:dparam:`data_sym_mat_tol_large` controls when an :math:`e_{i,j}` is considered large.</cmnt>
  </c>
  <c name="MSK_RES_ERR_LICENSE" val="1000">
   <cmnt>Invalid license.</cmnt>
  </c>
  <c name="MSK_RES_ERR_LICENSE_EXPIRED" val="1001">
   <cmnt>The license has expired.</cmnt>
  </c>
  <c name="MSK_RES_ERR_LICENSE_VERSION" val="1002">
   <cmnt>The license is valid for another version of |mosek|.</cmnt>
  </c>
  <c name="MSK_RES_ERR_SIZE_LICENSE" val="1005">
   <cmnt>The problem is bigger than the license.</cmnt>
  </c>
  <c name="MSK_RES_ERR_PROB_LICENSE" val="1006">
   <cmnt>The software is not licensed to solve the problem.</cmnt>
  </c>
  <c name="MSK_RES_ERR_FILE_LICENSE" val="1007">
   <cmnt>Invalid license file.</cmnt>
  </c>
  <c name="MSK_RES_ERR_MISSING_LICENSE_FILE" val="1008">
   <cmnt>|mosek| cannot find license file or a token server. See the |mosek| licensing manual for details.</cmnt>
  </c>
  <c name="MSK_RES_ERR_SIZE_LICENSE_CON" val="1010">
   <cmnt>The problem has too many constraints to be solved with the available license.</cmnt>
  </c>
  <c name="MSK_RES_ERR_SIZE_LICENSE_VAR" val="1011">
   <cmnt>The problem has too many variables to be solved with the available license.</cmnt>
  </c>
  <c name="MSK_RES_ERR_SIZE_LICENSE_INTVAR" val="1012">
   <cmnt>The problem contains too many integer variables to be solved with the available license.</cmnt>
  </c>
  <c name="MSK_RES_ERR_OPTIMIZER_LICENSE" val="1013">
   <cmnt>The optimizer required is not licensed.</cmnt>
  </c>
  <c name="MSK_RES_ERR_FLEXLM" val="1014">
   <cmnt>The |flexlm| license manager reported an error.</cmnt>
  </c>
  <c name="MSK_RES_ERR_LICENSE_SERVER" val="1015">
   <cmnt>The license server is not responding.</cmnt>
  </c>
  <c name="MSK_RES_ERR_LICENSE_MAX" val="1016">
   <cmnt>Maximum number of licenses is reached.</cmnt>
  </c>
  <c name="MSK_RES_ERR_LICENSE_MOSEKLM_DAEMON" val="1017">
   <cmnt>The MOSEKLM license manager daemon is not up and running.</cmnt>
  </c>
  <c name="MSK_RES_ERR_LICENSE_FEATURE" val="1018">
   <cmnt>A requested feature is not available in the license file(s). Most likely due to an incorrect license system setup.</cmnt>
  </c>
  <c name="MSK_RES_ERR_PLATFORM_NOT_LICENSED" val="1019">
   <cmnt>A requested license feature is not available for the required platform.</cmnt>
  </c>
  <c name="MSK_RES_ERR_LICENSE_CANNOT_ALLOCATE" val="1020">
   <cmnt>The license system cannot allocate the memory required.</cmnt>
  </c>
  <c name="MSK_RES_ERR_LICENSE_CANNOT_CONNECT" val="1021">
   <cmnt>|mosek| cannot connect to the license server.
Most likely the license server is not up and running.</cmnt>
  </c>
  <c name="MSK_RES_ERR_LICENSE_INVALID_HOSTID" val="1025">
   <cmnt>The host ID specified in the license file does not match the host ID of the computer.</cmnt>
  </c>
  <c name="MSK_RES_ERR_LICENSE_SERVER_VERSION" val="1026">
   <cmnt>The version specified in the checkout request is greater than the highest version number the daemon supports.</cmnt>
  </c>
  <c name="MSK_RES_ERR_LICENSE_NO_SERVER_SUPPORT" val="1027">
   <cmnt>The license server does not support the requested feature.
Possible reasons for this error include:

* The feature has expired.
* The feature's start date is later than today's date.
* The version requested is higher than feature's the highest supported version.
* A corrupted license file.

Try restarting the license and inspect the license server debug file, usually called ``lmgrd.log``.</cmnt>
  </c>
  <c name="MSK_RES_ERR_LICENSE_NO_SERVER_LINE" val="1028">
   <cmnt>There is no ``SERVER`` line in the license file. All non-zero license count features need at least one ``SERVER`` line.</cmnt>
  </c>
  <c name="MSK_RES_ERR_OLDER_DLL" val="1035">
   <cmnt>The dynamic link library is older than the specified version.</cmnt>
  </c>
  <c name="MSK_RES_ERR_NEWER_DLL" val="1036">
   <cmnt>The dynamic link library is newer than the specified version.</cmnt>
  </c>
  <c name="MSK_RES_ERR_LINK_FILE_DLL" val="1040">
   <cmnt>A file cannot be linked to a stream in the DLL version.</cmnt>
  </c>
  <c name="MSK_RES_ERR_THREAD_MUTEX_INIT" val="1045">
   <cmnt>Could not initialize a mutex.</cmnt>
  </c>
  <c name="MSK_RES_ERR_THREAD_MUTEX_LOCK" val="1046">
   <cmnt>Could not lock a mutex.</cmnt>
  </c>
  <c name="MSK_RES_ERR_THREAD_MUTEX_UNLOCK" val="1047">
   <cmnt>Could not unlock a mutex.</cmnt>
  </c>
  <c name="MSK_RES_ERR_THREAD_CREATE" val="1048">
   <cmnt>Could not create a thread. This error may occur if a large
number of environments are created and not deleted again.
In any case it is a good practice to minimize the number of
environments created.</cmnt>
  </c>
  <c name="MSK_RES_ERR_THREAD_COND_INIT" val="1049">
   <cmnt>Could not initialize a condition.</cmnt>
  </c>
  <c name="MSK_RES_ERR_UNKNOWN" val="1050">
   <cmnt>Unknown error.</cmnt>
  </c>
  <c name="MSK_RES_ERR_SPACE" val="1051">
   <cmnt>Out of space.</cmnt>
  </c>
  <c name="MSK_RES_ERR_FILE_OPEN" val="1052">
   <cmnt>Error while opening a file.</cmnt>
  </c>
  <c name="MSK_RES_ERR_FILE_READ" val="1053">
   <cmnt>File read error.</cmnt>
  </c>
  <c name="MSK_RES_ERR_FILE_WRITE" val="1054">
   <cmnt>File write error.</cmnt>
  </c>
  <c name="MSK_RES_ERR_DATA_FILE_EXT" val="1055">
   <cmnt>The data file format cannot be determined from the file name.</cmnt>
  </c>
  <c name="MSK_RES_ERR_INVALID_FILE_NAME" val="1056">
   <cmnt>An invalid file name has been specified.</cmnt>
  </c>
  <c name="MSK_RES_ERR_INVALID_SOL_FILE_NAME" val="1057">
   <cmnt>An invalid file name has been specified.</cmnt>
  </c>
  <c name="MSK_RES_ERR_END_OF_FILE" val="1059">
   <cmnt>End of file reached.</cmnt>
  </c>
  <c name="MSK_RES_ERR_NULL_ENV" val="1060">
   <cmnt>``env`` is a |null| pointer.</cmnt>
  </c>
  <c name="MSK_RES_ERR_NULL_TASK" val="1061">
   <cmnt>``task`` is a |null| pointer.</cmnt>
  </c>
  <c name="MSK_RES_ERR_INVALID_STREAM" val="1062">
   <cmnt>An invalid stream is referenced.</cmnt>
  </c>
  <c name="MSK_RES_ERR_NO_INIT_ENV" val="1063">
   <cmnt>``env`` is not initialized.</cmnt>
  </c>
  <c name="MSK_RES_ERR_INVALID_TASK" val="1064">
   <cmnt>The ``task`` is invalid.</cmnt>
  </c>
  <c name="MSK_RES_ERR_NULL_POINTER" val="1065">
   <cmnt>An argument to a function is unexpectedly a |null| pointer.</cmnt>
  </c>
  <c name="MSK_RES_ERR_LIVING_TASKS" val="1066">
   <cmnt>All tasks associated with an enviroment must be deleted
before the environment is deleted. There are still some undeleted tasks.</cmnt>
  </c>
  <c name="MSK_RES_ERR_BLANK_NAME" val="1070">
   <cmnt>An all blank name has been specified.</cmnt>
  </c>
  <c name="MSK_RES_ERR_DUP_NAME" val="1071">
   <cmnt>The same name was used multiple times for the same problem item type.</cmnt>
  </c>
  <c name="MSK_RES_ERR_FORMAT_STRING" val="1072">
   <cmnt>The name format string is invalid.</cmnt>
  </c>
  <c name="MSK_RES_ERR_INVALID_OBJ_NAME" val="1075">
   <cmnt>An invalid objective name is specified.</cmnt>
  </c>
  <c name="MSK_RES_ERR_INVALID_CON_NAME" val="1076">
   <cmnt>An invalid constraint name is used.</cmnt>
  </c>
  <c name="MSK_RES_ERR_INVALID_VAR_NAME" val="1077">
   <cmnt>An invalid variable name is used.</cmnt>
  </c>
  <c name="MSK_RES_ERR_INVALID_CONE_NAME" val="1078">
   <cmnt>An invalid cone name is used.</cmnt>
  </c>
  <c name="MSK_RES_ERR_INVALID_BARVAR_NAME" val="1079">
   <cmnt>An invalid symmetric matrix variable name is used.</cmnt>
  </c>
  <c name="MSK_RES_ERR_SPACE_LEAKING" val="1080">
   <cmnt>|mosek| is leaking memory. This can be due to either an incorrect use of |mosek| or a bug.</cmnt>
  </c>
  <c name="MSK_RES_ERR_SPACE_NO_INFO" val="1081">
   <cmnt>No available information about the space usage.</cmnt>
  </c>
  <c name="MSK_RES_ERR_READ_FORMAT" val="1090">
   <cmnt>The specified format cannot be read.</cmnt>
  </c>
  <c name="MSK_RES_ERR_MPS_FILE" val="1100">
   <cmnt>An error occurred while reading an MPS file.</cmnt>
  </c>
  <c name="MSK_RES_ERR_MPS_INV_FIELD" val="1101">
   <cmnt>A field in the MPS file is invalid. Probably it is too wide.</cmnt>
  </c>
  <c name="MSK_RES_ERR_MPS_INV_MARKER" val="1102">
   <cmnt>An invalid marker has been specified in the MPS file.</cmnt>
  </c>
  <c name="MSK_RES_ERR_MPS_NULL_CON_NAME" val="1103">
   <cmnt>An empty constraint name is used in an MPS file.</cmnt>
  </c>
  <c name="MSK_RES_ERR_MPS_NULL_VAR_NAME" val="1104">
   <cmnt>An empty variable name is used in an MPS file.</cmnt>
  </c>
  <c name="MSK_RES_ERR_MPS_UNDEF_CON_NAME" val="1105">
   <cmnt>An undefined constraint name occurred in an MPS file.</cmnt>
  </c>
  <c name="MSK_RES_ERR_MPS_UNDEF_VAR_NAME" val="1106">
   <cmnt>An undefined variable name occurred in an MPS file.</cmnt>
  </c>
  <c name="MSK_RES_ERR_MPS_INV_CON_KEY" val="1107">
   <cmnt>An invalid constraint key occurred in an MPS file.</cmnt>
  </c>
  <c name="MSK_RES_ERR_MPS_INV_BOUND_KEY" val="1108">
   <cmnt>An invalid bound key occurred in an MPS file.</cmnt>
  </c>
  <c name="MSK_RES_ERR_MPS_INV_SEC_NAME" val="1109">
   <cmnt>An invalid section name occurred in an MPS file.</cmnt>
  </c>
  <c name="MSK_RES_ERR_MPS_NO_OBJECTIVE" val="1110">
   <cmnt>No objective is defined in an MPS file.</cmnt>
  </c>
  <c name="MSK_RES_ERR_MPS_SPLITTED_VAR" val="1111">
   <cmnt>All elements in a column of the :math:`A` matrix must be specified consecutively.  Hence, it is illegal to specify non-zero elements in :math:`A` for variable 1, then for variable 2 and then variable 1 again.</cmnt>
  </c>
  <c name="MSK_RES_ERR_MPS_MUL_CON_NAME" val="1112">
   <cmnt>A constraint name was specified multiple times in the ``ROWS`` section.</cmnt>
  </c>
  <c name="MSK_RES_ERR_MPS_MUL_QSEC" val="1113">
   <cmnt>Multiple ``QSECTION``\ s are specified for a constraint in the MPS data file.</cmnt>
  </c>
  <c name="MSK_RES_ERR_MPS_MUL_QOBJ" val="1114">
   <cmnt>The Q term in the objective
is specified multiple times in the MPS data file.</cmnt>
  </c>
  <c name="MSK_RES_ERR_MPS_INV_SEC_ORDER" val="1115">
   <cmnt>The sections in the MPS data file
are not in the correct order.</cmnt>
  </c>
  <c name="MSK_RES_ERR_MPS_MUL_CSEC" val="1116">
   <cmnt>Multiple ``CSECTION``\ s are given the same name.</cmnt>
  </c>
  <c name="MSK_RES_ERR_MPS_CONE_TYPE" val="1117">
   <cmnt>Invalid cone type specified in a ``CSECTION``\ .</cmnt>
  </c>
  <c name="MSK_RES_ERR_MPS_CONE_OVERLAP" val="1118">
   <cmnt>A variable is specified to be a member of several cones.</cmnt>
  </c>
  <c name="MSK_RES_ERR_MPS_CONE_REPEAT" val="1119">
   <cmnt>A variable is repeated within the ``CSECTION``\ .</cmnt>
  </c>
  <c name="MSK_RES_ERR_MPS_NON_SYMMETRIC_Q" val="1120">
   <cmnt>A non symmetric matrix has been speciefied.</cmnt>
  </c>
  <c name="MSK_RES_ERR_MPS_DUPLICATE_Q_ELEMENT" val="1121">
   <cmnt>Duplicate elements is specfied in a :math:`Q` matrix.</cmnt>
  </c>
  <c name="MSK_RES_ERR_MPS_INVALID_OBJSENSE" val="1122">
   <cmnt>An invalid objective sense is specified.</cmnt>
  </c>
  <c name="MSK_RES_ERR_MPS_TAB_IN_FIELD2" val="1125">
   <cmnt>A tab char occurred in field 2.</cmnt>
  </c>
  <c name="MSK_RES_ERR_MPS_TAB_IN_FIELD3" val="1126">
   <cmnt>A tab char occurred in field 3.</cmnt>
  </c>
  <c name="MSK_RES_ERR_MPS_TAB_IN_FIELD5" val="1127">
   <cmnt>A tab char occurred in field 5.</cmnt>
  </c>
  <c name="MSK_RES_ERR_MPS_INVALID_OBJ_NAME" val="1128">
   <cmnt>An invalid objective name is specified.</cmnt>
  </c>
  <c name="MSK_RES_ERR_LP_INCOMPATIBLE" val="1150">
   <cmnt>The problem cannot be written to an LP formatted file.</cmnt>
  </c>
  <c name="MSK_RES_ERR_LP_EMPTY" val="1151">
   <cmnt>The problem cannot be written to an LP formatted file.</cmnt>
  </c>
  <c name="MSK_RES_ERR_LP_DUP_SLACK_NAME" val="1152">
   <cmnt>The name of the slack variable added to a ranged constraint already exists.</cmnt>
  </c>
  <c name="MSK_RES_ERR_WRITE_MPS_INVALID_NAME" val="1153">
   <cmnt>An invalid name is created while writing an MPS file. Usually this will make the MPS file unreadable.</cmnt>
  </c>
  <c name="MSK_RES_ERR_LP_INVALID_VAR_NAME" val="1154">
   <cmnt>A variable name is invalid when used in an LP formatted file.</cmnt>
  </c>
  <c name="MSK_RES_ERR_LP_FREE_CONSTRAINT" val="1155">
   <cmnt>Free constraints cannot be written in LP file format.</cmnt>
  </c>
  <c name="MSK_RES_ERR_WRITE_OPF_INVALID_VAR_NAME" val="1156">
   <cmnt>Empty variable names cannot be written to OPF files.</cmnt>
  </c>
  <c name="MSK_RES_ERR_LP_FILE_FORMAT" val="1157">
   <cmnt>Syntax error in an LP file.</cmnt>
  </c>
  <c name="MSK_RES_ERR_WRITE_LP_FORMAT" val="1158">
   <cmnt>Problem cannot be written as an LP file.</cmnt>
  </c>
  <c name="MSK_RES_ERR_READ_LP_MISSING_END_TAG" val="1159">
   <cmnt>Syntax error in LP file. Possibly missing End tag.</cmnt>
  </c>
  <c name="MSK_RES_ERR_LP_FORMAT" val="1160">
   <cmnt>Syntax error in an LP file.</cmnt>
  </c>
  <c name="MSK_RES_ERR_WRITE_LP_NON_UNIQUE_NAME" val="1161">
   <cmnt>An auto-generated name is not unique.</cmnt>
  </c>
  <c name="MSK_RES_ERR_READ_LP_NONEXISTING_NAME" val="1162">
   <cmnt>A variable never occurred in objective or constraints.</cmnt>
  </c>
  <c name="MSK_RES_ERR_LP_WRITE_CONIC_PROBLEM" val="1163">
   <cmnt>The problem contains cones that cannot be written to an LP formatted file.</cmnt>
  </c>
  <c name="MSK_RES_ERR_LP_WRITE_GECO_PROBLEM" val="1164">
   <cmnt>The problem contains general convex terms that cannot be written to an LP formatted file.</cmnt>
  </c>
  <c name="MSK_RES_ERR_WRITING_FILE" val="1166">
   <cmnt>An error occurred while writing file</cmnt>
  </c>
  <c name="MSK_RES_ERR_PTF_FORMAT" val="1167">
   <cmnt>Syntax error in an PTF file</cmnt>
  </c>
  <c name="MSK_RES_ERR_OPF_FORMAT" val="1168">
   <cmnt>Syntax error in an OPF file</cmnt>
  </c>
  <c name="MSK_RES_ERR_OPF_NEW_VARIABLE" val="1169">
   <cmnt>Introducing new variables is now allowed. When a ``[variables]`` section is present, it is not allowed to introduce new variables later in the problem.</cmnt>
  </c>
  <c name="MSK_RES_ERR_INVALID_NAME_IN_SOL_FILE" val="1170">
   <cmnt>An invalid name occurred in a solution file.</cmnt>
  </c>
  <c name="MSK_RES_ERR_LP_INVALID_CON_NAME" val="1171">
   <cmnt>A constraint name is invalid when used in an LP formatted file.</cmnt>
  </c>
  <c name="MSK_RES_ERR_OPF_PREMATURE_EOF" val="1172">
   <cmnt>Premature end of file in an OPF file.</cmnt>
  </c>
  <c name="MSK_RES_ERR_JSON_SYNTAX" val="1175">
   <cmnt>Syntax error in an JSON data</cmnt>
  </c>
  <c name="MSK_RES_ERR_JSON_STRING" val="1176">
   <cmnt>Error in JSON string.</cmnt>
  </c>
  <c name="MSK_RES_ERR_JSON_NUMBER_OVERFLOW" val="1177">
   <cmnt>Invalid number entry - wrong type or value overflow.</cmnt>
  </c>
  <c name="MSK_RES_ERR_JSON_FORMAT" val="1178">
   <cmnt>Error in an JSON Task file</cmnt>
  </c>
  <c name="MSK_RES_ERR_JSON_DATA" val="1179">
   <cmnt>Inconsistent data in JSON Task file</cmnt>
  </c>
  <c name="MSK_RES_ERR_JSON_MISSING_DATA" val="1180">
   <cmnt>Missing data section in JSON task file.</cmnt>
  </c>
  <c name="MSK_RES_ERR_ARGUMENT_LENNEQ" val="1197">
   <cmnt>Incorrect length of arguments.</cmnt>
  </c>
  <c name="MSK_RES_ERR_ARGUMENT_TYPE" val="1198">
   <cmnt>Incorrect argument type.</cmnt>
  </c>
  <c name="MSK_RES_ERR_NUM_ARGUMENTS" val="1199">
   <cmnt>Incorrect number of function arguments.</cmnt>
  </c>
  <c name="MSK_RES_ERR_IN_ARGUMENT" val="1200">
   <cmnt>A function argument is incorrect.</cmnt>
  </c>
  <c name="MSK_RES_ERR_ARGUMENT_DIMENSION" val="1201">
   <cmnt>A function argument is of incorrect dimension.</cmnt>
  </c>
  <c name="MSK_RES_ERR_SHAPE_IS_TOO_LARGE" val="1202">
   <cmnt>The size of the n-dimensional shape is too large.</cmnt>
  </c>
  <c name="MSK_RES_ERR_INDEX_IS_TOO_SMALL" val="1203">
   <cmnt>An index in an argument is too small.</cmnt>
  </c>
  <c name="MSK_RES_ERR_INDEX_IS_TOO_LARGE" val="1204">
   <cmnt>An index in an argument is too large.</cmnt>
  </c>
  <c name="MSK_RES_ERR_PARAM_NAME" val="1205">
   <cmnt>The parameter name is not correct.</cmnt>
  </c>
  <c name="MSK_RES_ERR_PARAM_NAME_DOU" val="1206">
   <cmnt>The parameter name is not correct for a double parameter.</cmnt>
  </c>
  <c name="MSK_RES_ERR_PARAM_NAME_INT" val="1207">
   <cmnt>The parameter name is not correct for an integer parameter.</cmnt>
  </c>
  <c name="MSK_RES_ERR_PARAM_NAME_STR" val="1208">
   <cmnt>The parameter name is not correct for a string parameter.</cmnt>
  </c>
  <c name="MSK_RES_ERR_PARAM_INDEX" val="1210">
   <cmnt>Parameter index is out of range.</cmnt>
  </c>
  <c name="MSK_RES_ERR_PARAM_IS_TOO_LARGE" val="1215">
   <cmnt>The parameter value is too large.</cmnt>
  </c>
  <c name="MSK_RES_ERR_PARAM_IS_TOO_SMALL" val="1216">
   <cmnt>The parameter value is too small.</cmnt>
  </c>
  <c name="MSK_RES_ERR_PARAM_VALUE_STR" val="1217">
   <cmnt>The parameter value string is incorrect.</cmnt>
  </c>
  <c name="MSK_RES_ERR_PARAM_TYPE" val="1218">
   <cmnt>The parameter type is invalid.</cmnt>
  </c>
  <c name="MSK_RES_ERR_INF_DOU_INDEX" val="1219">
   <cmnt>A double information index is out of range for the specified type.</cmnt>
  </c>
  <c name="MSK_RES_ERR_INF_INT_INDEX" val="1220">
   <cmnt>An integer information index is out of range for the specified type.</cmnt>
  </c>
  <c name="MSK_RES_ERR_INDEX_ARR_IS_TOO_SMALL" val="1221">
   <cmnt>An index in an array argument is too small.</cmnt>
  </c>
  <c name="MSK_RES_ERR_INDEX_ARR_IS_TOO_LARGE" val="1222">
   <cmnt>An index in an array argument is too large.</cmnt>
  </c>
  <c name="MSK_RES_ERR_INF_LINT_INDEX" val="1225">
   <cmnt>A long integer information index is out of range for the specified type.</cmnt>
  </c>
  <c name="MSK_RES_ERR_ARG_IS_TOO_SMALL" val="1226">
   <cmnt>The value of a argument is too small.</cmnt>
  </c>
  <c name="MSK_RES_ERR_ARG_IS_TOO_LARGE" val="1227">
   <cmnt>The value of a argument is too large.</cmnt>
  </c>
  <c name="MSK_RES_ERR_INVALID_WHICHSOL" val="1228">
   <cmnt>``whichsol`` is invalid.</cmnt>
  </c>
  <c name="MSK_RES_ERR_INF_DOU_NAME" val="1230">
   <cmnt>A double information name is invalid.</cmnt>
  </c>
  <c name="MSK_RES_ERR_INF_INT_NAME" val="1231">
   <cmnt>An integer information name is invalid.</cmnt>
  </c>
  <c name="MSK_RES_ERR_INF_TYPE" val="1232">
   <cmnt>The information type is invalid.</cmnt>
  </c>
  <c name="MSK_RES_ERR_INF_LINT_NAME" val="1234">
   <cmnt>A long integer information name is invalid.</cmnt>
  </c>
  <c name="MSK_RES_ERR_INDEX" val="1235">
   <cmnt>An index is out of range.</cmnt>
  </c>
  <c name="MSK_RES_ERR_WHICHSOL" val="1236">
   <cmnt>The solution defined by ``whichsol`` does not exists.</cmnt>
  </c>
  <c name="MSK_RES_ERR_SOLITEM" val="1237">
   <cmnt>The solution item number ``solitem`` is invalid. Please note that :msk:const:`solitem.snx` is invalid for the basic solution.</cmnt>
  </c>
  <c name="MSK_RES_ERR_WHICHITEM_NOT_ALLOWED" val="1238">
   <cmnt>``whichitem`` is unacceptable.</cmnt>
  </c>
  <c name="MSK_RES_ERR_MAXNUMCON" val="1240">
   <cmnt>The maximum number of constraints specified is smaller than the number of
constraints in the task.</cmnt>
  </c>
  <c name="MSK_RES_ERR_MAXNUMVAR" val="1241">
   <cmnt>The maximum number of variables specified is smaller than the number of
variables in the task.</cmnt>
  </c>
  <c name="MSK_RES_ERR_MAXNUMBARVAR" val="1242">
   <cmnt>The maximum number of semidefinite variables specified is smaller than the number of semidefinite variables in the task.</cmnt>
  </c>
  <c name="MSK_RES_ERR_MAXNUMQNZ" val="1243">
   <cmnt>The maximum number of non-zeros specified for the :math:`Q` matrices is smaller than the number of non-zeros in the current :math:`Q` matrices.</cmnt>
  </c>
  <c name="MSK_RES_ERR_TOO_SMALL_MAX_NUM_NZ" val="1245">
   <cmnt>The maximum number of non-zeros specified is too small.</cmnt>
  </c>
  <c name="MSK_RES_ERR_INVALID_IDX" val="1246">
   <cmnt>A specified index is invalid.</cmnt>
  </c>
  <c name="MSK_RES_ERR_INVALID_MAX_NUM" val="1247">
   <cmnt>A specified index is invalid.</cmnt>
  </c>
  <c name="MSK_RES_ERR_NUMCONLIM" val="1250">
   <cmnt>Maximum number of constraints limit is exceeded.</cmnt>
  </c>
  <c name="MSK_RES_ERR_NUMVARLIM" val="1251">
   <cmnt>Maximum number of variables limit is exceeded.</cmnt>
  </c>
  <c name="MSK_RES_ERR_TOO_SMALL_MAXNUMANZ" val="1252">
   <cmnt>The maximum number of non-zeros specified for :math:`A` is smaller than the number of non-zeros in the current :math:`A`.</cmnt>
  </c>
  <c name="MSK_RES_ERR_INV_APTRE" val="1253">
   <cmnt>``aptre[j]`` is strictly smaller than ``aptrb[j]`` for some ``j``.</cmnt>
  </c>
  <c name="MSK_RES_ERR_MUL_A_ELEMENT" val="1254">
   <cmnt>An element in :math:`A` is defined multiple times.</cmnt>
  </c>
  <c name="MSK_RES_ERR_INV_BK" val="1255">
   <cmnt>Invalid bound key.</cmnt>
  </c>
  <c name="MSK_RES_ERR_INV_BKC" val="1256">
   <cmnt>Invalid bound key is specified for a constraint.</cmnt>
  </c>
  <c name="MSK_RES_ERR_INV_BKX" val="1257">
   <cmnt>An invalid bound key is specified for a variable.</cmnt>
  </c>
  <c name="MSK_RES_ERR_INV_VAR_TYPE" val="1258">
   <cmnt>An invalid variable type is specified for a variable.</cmnt>
  </c>
  <c name="MSK_RES_ERR_SOLVER_PROBTYPE" val="1259">
   <cmnt>Problem type does not match the chosen optimizer.</cmnt>
  </c>
  <c name="MSK_RES_ERR_OBJECTIVE_RANGE" val="1260">
   <cmnt>Empty objective range.</cmnt>
  </c>
  <c name="MSK_RES_ERR_UNDEF_SOLUTION" val="1265">
   <cmnt>|mosek| has the following solution types:

* an interior-point solution,
* a basic solution,
* and an integer solution.

Each optimizer may set one or more of these solutions; e.g by default a successful optimization with the interior-point optimizer defines the interior-point solution and, for linear problems, also the basic  solution. This error occurs when asking for a solution  or for information about a solution that is not defined.</cmnt>
  </c>
  <c name="MSK_RES_ERR_BASIS" val="1266">
   <cmnt>An invalid basis is specified. Either
too many or too few basis variables are specified.</cmnt>
  </c>
  <c name="MSK_RES_ERR_INV_SKC" val="1267">
   <cmnt>Invalid value in ``skc``.</cmnt>
  </c>
  <c name="MSK_RES_ERR_INV_SKX" val="1268">
   <cmnt>Invalid value in ``skx``.</cmnt>
  </c>
  <c name="MSK_RES_ERR_INV_SKN" val="1274">
   <cmnt>Invalid value in ``skn``.</cmnt>
  </c>
  <c name="MSK_RES_ERR_INV_SK_STR" val="1269">
   <cmnt>Invalid status key string encountered.</cmnt>
  </c>
  <c name="MSK_RES_ERR_INV_SK" val="1270">
   <cmnt>Invalid status key code.</cmnt>
  </c>
  <c name="MSK_RES_ERR_INV_CONE_TYPE_STR" val="1271">
   <cmnt>Invalid cone type string encountered.</cmnt>
  </c>
  <c name="MSK_RES_ERR_INV_CONE_TYPE" val="1272">
   <cmnt>Invalid cone type code is encountered.</cmnt>
  </c>
  <c name="MSK_RES_ERR_INVALID_SURPLUS" val="1275">
   <cmnt>Invalid surplus.</cmnt>
  </c>
  <c name="MSK_RES_ERR_INV_NAME_ITEM" val="1280">
   <cmnt>An invalid name item code is used.</cmnt>
  </c>
  <c name="MSK_RES_ERR_PRO_ITEM" val="1281">
   <cmnt>An invalid problem is used.</cmnt>
  </c>
  <c name="MSK_RES_ERR_INVALID_FORMAT_TYPE" val="1283">
   <cmnt>Invalid format type.</cmnt>
  </c>
  <c name="MSK_RES_ERR_FIRSTI" val="1285">
   <cmnt>Invalid ``firsti``.</cmnt>
  </c>
  <c name="MSK_RES_ERR_LASTI" val="1286">
   <cmnt>Invalid ``lasti``.</cmnt>
  </c>
  <c name="MSK_RES_ERR_FIRSTJ" val="1287">
   <cmnt>Invalid ``firstj``.</cmnt>
  </c>
  <c name="MSK_RES_ERR_LASTJ" val="1288">
   <cmnt>Invalid ``lastj``.</cmnt>
  </c>
  <c name="MSK_RES_ERR_MAX_LEN_IS_TOO_SMALL" val="1289">
   <cmnt>A maximum length that is too small has been specified.</cmnt>
  </c>
  <c name="MSK_RES_ERR_NONLINEAR_EQUALITY" val="1290">
   <cmnt>The model contains a nonlinear equality which defines a nonconvex set.</cmnt>
  </c>
  <c name="MSK_RES_ERR_NONCONVEX" val="1291">
   <cmnt>The optimization problem is nonconvex.</cmnt>
  </c>
  <c name="MSK_RES_ERR_NONLINEAR_RANGED" val="1292">
   <cmnt>Nonlinear constraints with finite lower and upper bound always define a nonconvex feasible set.</cmnt>
  </c>
  <c name="MSK_RES_ERR_CON_Q_NOT_PSD" val="1293">
   <cmnt>The quadratic constraint matrix is not positive semidefinite as expected for a constraint with finite upper bound. This results in a nonconvex problem. The parameter :msk:dparam:`check_convexity_rel_tol` can be used to relax the convexity check.</cmnt>
  </c>
  <c name="MSK_RES_ERR_CON_Q_NOT_NSD" val="1294">
   <cmnt>The quadratic constraint matrix is not negative semidefinite as expected for a constraint with finite lower bound. This results in a nonconvex problem.  The parameter :msk:dparam:`check_convexity_rel_tol` can be used to relax the convexity check.</cmnt>
  </c>
  <c name="MSK_RES_ERR_OBJ_Q_NOT_PSD" val="1295">
   <cmnt>The quadratic coefficient matrix in the objective is not positive semidefinite as expected for a minimization problem.  The parameter :msk:dparam:`check_convexity_rel_tol` can be used to relax the convexity check.</cmnt>
  </c>
  <c name="MSK_RES_ERR_OBJ_Q_NOT_NSD" val="1296">
   <cmnt>The quadratic coefficient matrix in the objective is not negative semidefinite as expected for a maximization problem. The parameter :msk:dparam:`check_convexity_rel_tol` can be used to relax the convexity check.</cmnt>
  </c>
  <c name="MSK_RES_ERR_ARGUMENT_PERM_ARRAY" val="1299">
   <cmnt>An invalid permutation array is specified.</cmnt>
  </c>
  <c name="MSK_RES_ERR_CONE_INDEX" val="1300">
   <cmnt>An index of a non-existing cone has been specified.</cmnt>
  </c>
  <c name="MSK_RES_ERR_CONE_SIZE" val="1301">
   <cmnt>A cone with incorrect number of members is specified.</cmnt>
  </c>
  <c name="MSK_RES_ERR_CONE_OVERLAP" val="1302">
   <cmnt>One or more of the variables in the cone to be added is already member of another cone. Now assume the variable is :math:`x_j` then add a new variable say
:math:`x_k` and the constraint

.. math::
   x_j = x_k

and then let :math:`x_k` be member of the cone to be appended.</cmnt>
  </c>
  <c name="MSK_RES_ERR_CONE_REP_VAR" val="1303">
   <cmnt>A variable is included multiple times in the cone.</cmnt>
  </c>
  <c name="MSK_RES_ERR_MAXNUMCONE" val="1304">
   <cmnt>The value specified for ``maxnumcone`` is too small.</cmnt>
  </c>
  <c name="MSK_RES_ERR_CONE_TYPE" val="1305">
   <cmnt>Invalid cone type specified.</cmnt>
  </c>
  <c name="MSK_RES_ERR_CONE_TYPE_STR" val="1306">
   <cmnt>Invalid cone type specified.</cmnt>
  </c>
  <c name="MSK_RES_ERR_CONE_OVERLAP_APPEND" val="1307">
   <cmnt>The cone to be appended has one variable which is already member of another cone.</cmnt>
  </c>
  <c name="MSK_RES_ERR_REMOVE_CONE_VARIABLE" val="1310">
   <cmnt>A variable cannot be removed because it will make a cone invalid.</cmnt>
  </c>
  <c name="MSK_RES_ERR_APPENDING_TOO_BIG_CONE" val="1311">
   <cmnt>Trying to append a too big cone.</cmnt>
  </c>
  <c name="MSK_RES_ERR_CONE_PARAMETER" val="1320">
   <cmnt>An invalid cone parameter.</cmnt>
  </c>
  <c name="MSK_RES_ERR_SOL_FILE_INVALID_NUMBER" val="1350">
   <cmnt>An invalid number is specified in a solution file.</cmnt>
  </c>
  <c name="MSK_RES_ERR_HUGE_C" val="1375">
   <cmnt>A huge value in absolute size is specified for one :math:`c_j`.</cmnt>
  </c>
  <c name="MSK_RES_ERR_HUGE_AIJ" val="1380">
   <cmnt>A numerically huge value is specified for an :math:`a_{i,j}` element in :math:`A`.  The parameter  :msk:dparam:`data_tol_aij_huge` controls when an :math:`a_{i,j}` is considered huge.</cmnt>
  </c>
  <c name="MSK_RES_ERR_DUPLICATE_AIJ" val="1385">
   <cmnt>An element in the A matrix is specified twice.</cmnt>
  </c>
  <c name="MSK_RES_ERR_LOWER_BOUND_IS_A_NAN" val="1390">
   <cmnt>The lower bound specified is not a number (nan).</cmnt>
  </c>
  <c name="MSK_RES_ERR_UPPER_BOUND_IS_A_NAN" val="1391">
   <cmnt>The upper bound specified is not a number (nan).</cmnt>
  </c>
  <c name="MSK_RES_ERR_INFINITE_BOUND" val="1400">
   <cmnt>A numerically huge bound value is specified.</cmnt>
  </c>
  <c name="MSK_RES_ERR_INV_QOBJ_SUBI" val="1401">
   <cmnt>Invalid value in ``qosubi``.</cmnt>
  </c>
  <c name="MSK_RES_ERR_INV_QOBJ_SUBJ" val="1402">
   <cmnt>Invalid value in ``qosubj``.</cmnt>
  </c>
  <c name="MSK_RES_ERR_INV_QOBJ_VAL" val="1403">
   <cmnt>Invalid value in ``qoval``.</cmnt>
  </c>
  <c name="MSK_RES_ERR_INV_QCON_SUBK" val="1404">
   <cmnt>Invalid value in ``qcsubk``.</cmnt>
  </c>
  <c name="MSK_RES_ERR_INV_QCON_SUBI" val="1405">
   <cmnt>Invalid value in ``qcsubi``.</cmnt>
  </c>
  <c name="MSK_RES_ERR_INV_QCON_SUBJ" val="1406">
   <cmnt>Invalid value in ``qcsubj``.</cmnt>
  </c>
  <c name="MSK_RES_ERR_INV_QCON_VAL" val="1407">
   <cmnt>Invalid value in ``qcval``.</cmnt>
  </c>
  <c name="MSK_RES_ERR_QCON_SUBI_TOO_SMALL" val="1408">
   <cmnt>Invalid value in ``qcsubi``.</cmnt>
  </c>
  <c name="MSK_RES_ERR_QCON_SUBI_TOO_LARGE" val="1409">
   <cmnt>Invalid value in ``qcsubi``.</cmnt>
  </c>
  <c name="MSK_RES_ERR_QOBJ_UPPER_TRIANGLE" val="1415">
   <cmnt>An element in the upper triangle of :math:`Q^o` is specified. Only elements in the lower triangle should be specified.</cmnt>
  </c>
  <c name="MSK_RES_ERR_QCON_UPPER_TRIANGLE" val="1417">
   <cmnt>An element in the upper triangle of a :math:`Q^k` is specified. Only elements in the lower triangle should be specified.</cmnt>
  </c>
  <c name="MSK_RES_ERR_FIXED_BOUND_VALUES" val="1420">
   <cmnt>A fixed constraint/variable has been specified using the bound keys but the numerical value of the lower and upper
bound is different.</cmnt>
  </c>
  <c name="MSK_RES_ERR_TOO_SMALL_A_TRUNCATION_VALUE" val="1421">
   <cmnt>A too small value for the A trucation value is specified.</cmnt>
  </c>
  <c name="MSK_RES_ERR_INVALID_OBJECTIVE_SENSE" val="1445">
   <cmnt>An invalid objective sense is specified.</cmnt>
  </c>
  <c name="MSK_RES_ERR_UNDEFINED_OBJECTIVE_SENSE" val="1446">
   <cmnt>The objective sense has not been specified before the optimization.</cmnt>
  </c>
  <c name="MSK_RES_ERR_Y_IS_UNDEFINED" val="1449">
   <cmnt>The solution item :math:`y` is undefined.</cmnt>
  </c>
  <c name="MSK_RES_ERR_NAN_IN_DOUBLE_DATA" val="1450">
   <cmnt>An invalid floating point value was used in some double data.</cmnt>
  </c>
  <c name="MSK_RES_ERR_NAN_IN_BLC" val="1461">
   <cmnt>:math:`l^c` contains an invalid floating point value, i.e. a ``NaN``.</cmnt>
  </c>
  <c name="MSK_RES_ERR_NAN_IN_BUC" val="1462">
   <cmnt>:math:`u^c` contains an invalid floating point value, i.e. a ``NaN``.</cmnt>
  </c>
  <c name="MSK_RES_ERR_NAN_IN_C" val="1470">
   <cmnt>:math:`c` contains an invalid floating point value, i.e. a ``NaN``.</cmnt>
  </c>
  <c name="MSK_RES_ERR_NAN_IN_BLX" val="1471">
   <cmnt>:math:`l^x` contains an invalid floating point value, i.e. a ``NaN``.</cmnt>
  </c>
  <c name="MSK_RES_ERR_NAN_IN_BUX" val="1472">
   <cmnt>:math:`u^x` contains an invalid floating point value, i.e. a ``NaN``.</cmnt>
  </c>
  <c name="MSK_RES_ERR_INVALID_AIJ" val="1473">
   <cmnt>:math:`a_{i,j}` contains an invalid floating point value, i.e. a ``NaN`` or an infinite value.</cmnt>
  </c>
  <c name="MSK_RES_ERR_SYM_MAT_INVALID" val="1480">
   <cmnt>A symmetric matrix contains an invalid floating point value, i.e. a ``NaN`` or an infinite value.</cmnt>
  </c>
  <c name="MSK_RES_ERR_SYM_MAT_HUGE" val="1482">
   <cmnt>A symmetric matrix contains a huge value in absolute size. The parameter  :msk:dparam:`data_sym_mat_tol_huge` controls when an :math:`e_{i,j}` is considered huge.</cmnt>
  </c>
  <c name="MSK_RES_ERR_INV_PROBLEM" val="1500">
   <cmnt>Invalid problem type. Probably a nonconvex problem has been specified.</cmnt>
  </c>
  <c name="MSK_RES_ERR_MIXED_CONIC_AND_NL" val="1501">
   <cmnt>The problem contains nonlinear terms conic constraints. The requested operation cannot be applied to this type of problem.</cmnt>
  </c>
  <c name="MSK_RES_ERR_GLOBAL_INV_CONIC_PROBLEM" val="1503">
   <cmnt>The global optimizer can only be applied to problems without semidefinite variables.</cmnt>
  </c>
  <c name="MSK_RES_ERR_INV_OPTIMIZER" val="1550">
   <cmnt>An invalid optimizer has been chosen for the problem.</cmnt>
  </c>
  <c name="MSK_RES_ERR_MIO_NO_OPTIMIZER" val="1551">
   <cmnt>No optimizer is available for the current class of integer optimization problems.</cmnt>
  </c>
  <c name="MSK_RES_ERR_NO_OPTIMIZER_VAR_TYPE" val="1552">
   <cmnt>No optimizer is available for this class of optimization problems.</cmnt>
  </c>
  <c name="MSK_RES_ERR_FINAL_SOLUTION" val="1560">
   <cmnt>An error occurred during the solution finalization.</cmnt>
  </c>
  <c name="MSK_RES_ERR_FIRST" val="1570">
   <cmnt>Invalid ``first``.</cmnt>
  </c>
  <c name="MSK_RES_ERR_LAST" val="1571">
   <cmnt>Invalid index ``last``. A given index was out of expected range.</cmnt>
  </c>
  <c name="MSK_RES_ERR_SLICE_SIZE" val="1572">
   <cmnt>Invalid slice size specified.</cmnt>
  </c>
  <c name="MSK_RES_ERR_NEGATIVE_SURPLUS" val="1573">
   <cmnt>Negative surplus.</cmnt>
  </c>
  <c name="MSK_RES_ERR_NEGATIVE_APPEND" val="1578">
   <cmnt>Cannot append a negative number.</cmnt>
  </c>
  <c name="MSK_RES_ERR_POSTSOLVE" val="1580">
   <cmnt>An error occurred during the postsolve. Please contact |mosek| support.</cmnt>
  </c>
  <c name="MSK_RES_ERR_OVERFLOW" val="1590">
   <cmnt>A computation produced an overflow i.e. a very large number.</cmnt>
  </c>
  <c name="MSK_RES_ERR_NO_BASIS_SOL" val="1600">
   <cmnt>No basic solution is defined.</cmnt>
  </c>
  <c name="MSK_RES_ERR_BASIS_FACTOR" val="1610">
   <cmnt>The factorization of the basis is invalid.</cmnt>
  </c>
  <c name="MSK_RES_ERR_BASIS_SINGULAR" val="1615">
   <cmnt>The basis is singular and hence cannot be factored.</cmnt>
  </c>
  <c name="MSK_RES_ERR_FACTOR" val="1650">
   <cmnt>An error occurred while factorizing a matrix.</cmnt>
  </c>
  <c name="MSK_RES_ERR_FEASREPAIR_CANNOT_RELAX" val="1700">
   <cmnt>An optimization problem cannot be relaxed.</cmnt>
  </c>
  <c name="MSK_RES_ERR_FEASREPAIR_SOLVING_RELAXED" val="1701">
   <cmnt>The relaxed problem could not be solved to optimality. Please consult the log file for further details.</cmnt>
  </c>
  <c name="MSK_RES_ERR_FEASREPAIR_INCONSISTENT_BOUND" val="1702">
   <cmnt>The upper bound is less than the lower bound for a variable or a constraint.
Please correct this before running the feasibility repair.</cmnt>
  </c>
  <c name="MSK_RES_ERR_REPAIR_INVALID_PROBLEM" val="1710">
   <cmnt>The feasibility repair does not support the specified problem type.</cmnt>
  </c>
  <c name="MSK_RES_ERR_REPAIR_OPTIMIZATION_FAILED" val="1711">
   <cmnt>Computation the optimal relaxation failed. The cause may have been numerical problems.</cmnt>
  </c>
  <c name="MSK_RES_ERR_NAME_MAX_LEN" val="1750">
   <cmnt>A name is longer than the buffer that is supposed to hold it.</cmnt>
  </c>
  <c name="MSK_RES_ERR_NAME_IS_NULL" val="1760">
   <cmnt>The name buffer is a |null| pointer.</cmnt>
  </c>
  <c name="MSK_RES_ERR_INVALID_COMPRESSION" val="1800">
   <cmnt>Invalid compression type.</cmnt>
  </c>
  <c name="MSK_RES_ERR_INVALID_IOMODE" val="1801">
   <cmnt>Invalid io mode.</cmnt>
  </c>
  <c name="MSK_RES_ERR_NO_PRIMAL_INFEAS_CER" val="2000">
   <cmnt>A certificate of primal infeasibility is not available.</cmnt>
  </c>
  <c name="MSK_RES_ERR_NO_DUAL_INFEAS_CER" val="2001">
   <cmnt>A certificate of infeasibility is not available.</cmnt>
  </c>
  <c name="MSK_RES_ERR_NO_SOLUTION_IN_CALLBACK" val="2500">
   <cmnt>The required solution is not available.</cmnt>
  </c>
  <c name="MSK_RES_ERR_INV_MARKI" val="2501">
   <cmnt>Invalid value in marki.</cmnt>
  </c>
  <c name="MSK_RES_ERR_INV_MARKJ" val="2502">
   <cmnt>Invalid value in markj.</cmnt>
  </c>
  <c name="MSK_RES_ERR_INV_NUMI" val="2503">
   <cmnt>Invalid numi.</cmnt>
  </c>
  <c name="MSK_RES_ERR_INV_NUMJ" val="2504">
   <cmnt>Invalid numj.</cmnt>
  </c>
  <c name="MSK_RES_ERR_TASK_INCOMPATIBLE" val="2560">
   <cmnt>The Task file is incompatible with this platform. This results from reading a file on a 32 bit platform generated on a 64 bit platform.</cmnt>
  </c>
  <c name="MSK_RES_ERR_TASK_INVALID" val="2561">
   <cmnt>The Task file is invalid.</cmnt>
  </c>
  <c name="MSK_RES_ERR_TASK_WRITE" val="2562">
   <cmnt>Failed to write the task file.</cmnt>
  </c>
  <c name="MSK_RES_ERR_LU_MAX_NUM_TRIES" val="2800">
   <cmnt>Could not compute the LU factors of the matrix within the maximum number of allowed tries.</cmnt>
  </c>
  <c name="MSK_RES_ERR_INVALID_UTF8" val="2900">
   <cmnt>An invalid UTF8 string is encountered.</cmnt>
  </c>
  <c name="MSK_RES_ERR_INVALID_WCHAR" val="2901">
   <cmnt>An invalid ``wchar`` string is encountered.</cmnt>
  </c>
  <c name="MSK_RES_ERR_NO_DUAL_FOR_ITG_SOL" val="2950">
   <cmnt>No dual information is available for the integer solution.</cmnt>
  </c>
  <c name="MSK_RES_ERR_NO_SNX_FOR_BAS_SOL" val="2953">
   <cmnt>:math:`s_n^x` is not available for the basis solution.</cmnt>
  </c>
  <c name="MSK_RES_ERR_INTERNAL" val="3000">
   <cmnt>An internal error occurred. Please report this problem.</cmnt>
  </c>
  <c name="MSK_RES_ERR_API_ARRAY_TOO_SMALL" val="3001">
   <cmnt>An input array was too short.</cmnt>
  </c>
  <c name="MSK_RES_ERR_API_CB_CONNECT" val="3002">
   <cmnt>Failed to connect a callback object.</cmnt>
  </c>
  <c name="MSK_RES_ERR_API_FATAL_ERROR" val="3005">
   <cmnt>An internal error occurred in the API. Please report this problem.</cmnt>
  </c>
  <c name="MSK_RES_ERR_API_INTERNAL" val="3999">
   <cmnt>An internal fatal error occurred in an interface function.</cmnt>
  </c>
  <c name="MSK_RES_ERR_SEN_FORMAT" val="3050">
   <cmnt>Syntax error in sensitivity analysis file.</cmnt>
  </c>
  <c name="MSK_RES_ERR_SEN_UNDEF_NAME" val="3051">
   <cmnt>An undefined name was encountered in the sensitivity analysis file.</cmnt>
  </c>
  <c name="MSK_RES_ERR_SEN_INDEX_RANGE" val="3052">
   <cmnt>Index out of range in the sensitivity analysis file.</cmnt>
  </c>
  <c name="MSK_RES_ERR_SEN_BOUND_INVALID_UP" val="3053">
   <cmnt>Analysis of upper bound requested for an index, where no upper bound exists.</cmnt>
  </c>
  <c name="MSK_RES_ERR_SEN_BOUND_INVALID_LO" val="3054">
   <cmnt>Analysis of lower bound requested for an index, where no lower bound exists.</cmnt>
  </c>
  <c name="MSK_RES_ERR_SEN_INDEX_INVALID" val="3055">
   <cmnt>Invalid range given in the sensitivity file.</cmnt>
  </c>
  <c name="MSK_RES_ERR_SEN_INVALID_REGEXP" val="3056">
   <cmnt>Syntax error in regexp or regexp longer than 1024.</cmnt>
  </c>
  <c name="MSK_RES_ERR_SEN_SOLUTION_STATUS" val="3057">
   <cmnt>No optimal solution found to the original problem given for sensitivity analysis.</cmnt>
  </c>
  <c name="MSK_RES_ERR_SEN_NUMERICAL" val="3058">
   <cmnt>Numerical difficulties encountered performing the sensitivity analysis.</cmnt>
  </c>
  <c name="MSK_RES_ERR_SEN_UNHANDLED_PROBLEM_TYPE" val="3080">
   <cmnt>Sensitivity analysis cannot be performed for the specified problem. Sensitivity analysis is only possible for linear problems.</cmnt>
  </c>
  <c name="MSK_RES_ERR_UNB_STEP_SIZE" val="3100">
   <cmnt>A step size in an optimizer was unexpectedly unbounded. For instance, if the step-size becomes unbounded in phase 1 of the simplex algorithm then an error occurs. Normally this will happen only if the problem is badly formulated. Please contact |mosek| support if this error occurs.</cmnt>
  </c>
  <c name="MSK_RES_ERR_IDENTICAL_TASKS" val="3101">
   <cmnt>Some tasks related to this function call were identical. Unique tasks were expected.</cmnt>
  </c>
  <c name="MSK_RES_ERR_AD_INVALID_CODELIST" val="3102">
   <cmnt>The code list data was invalid.</cmnt>
  </c>
  <c name="MSK_RES_ERR_INTERNAL_TEST_FAILED" val="3500">
   <cmnt>An internal unit test function failed.</cmnt>
  </c>
  <c name="MSK_RES_ERR_XML_INVALID_PROBLEM_TYPE" val="3600">
   <cmnt>The problem type is not supported by the XML format.</cmnt>
  </c>
  <c name="MSK_RES_ERR_INVALID_AMPL_STUB" val="3700">
   <cmnt>Invalid AMPL stub.</cmnt>
  </c>
  <c name="MSK_RES_ERR_INT64_TO_INT32_CAST" val="3800">
   <cmnt>A 64 bit integer could not be cast to a 32 bit integer.</cmnt>
  </c>
  <c name="MSK_RES_ERR_SIZE_LICENSE_NUMCORES" val="3900">
   <cmnt>The computer contains more cpu cores than the license allows for.</cmnt>
  </c>
  <c name="MSK_RES_ERR_INFEAS_UNDEFINED" val="3910">
   <cmnt>The requested value is not defined for this solution type.</cmnt>
  </c>
  <c name="MSK_RES_ERR_NO_BARX_FOR_SOLUTION" val="3915">
   <cmnt>There is no :math:`\barX` available for the solution specified. In particular note there are no :math:`\barX` defined for the basic and integer solutions.</cmnt>
  </c>
  <c name="MSK_RES_ERR_NO_BARS_FOR_SOLUTION" val="3916">
   <cmnt>There is no :math:`\bar{s}` available for the solution specified. In particular note there are no :math:`\bar{s}` defined for the basic and integer solutions.</cmnt>
  </c>
  <c name="MSK_RES_ERR_BAR_VAR_DIM" val="3920">
   <cmnt>The dimension of a symmetric matrix variable has to be greater than 0.</cmnt>
  </c>
  <c name="MSK_RES_ERR_SYM_MAT_INVALID_ROW_INDEX" val="3940">
   <cmnt>A row index specified for sparse symmetric matrix is invalid.</cmnt>
  </c>
  <c name="MSK_RES_ERR_SYM_MAT_INVALID_COL_INDEX" val="3941">
   <cmnt>A column index specified for sparse symmetric matrix is invalid.</cmnt>
  </c>
  <c name="MSK_RES_ERR_SYM_MAT_NOT_LOWER_TRINGULAR" val="3942">
   <cmnt>Only the lower triangular part of sparse symmetric matrix should be specified.</cmnt>
  </c>
  <c name="MSK_RES_ERR_SYM_MAT_INVALID_VALUE" val="3943">
   <cmnt>The numerical value specified in a sparse symmetric matrix is not a floating point value.</cmnt>
  </c>
  <c name="MSK_RES_ERR_SYM_MAT_DUPLICATE" val="3944">
   <cmnt>A value in a symmetric matric as been specified more than once.</cmnt>
  </c>
  <c name="MSK_RES_ERR_INVALID_SYM_MAT_DIM" val="3950">
   <cmnt>A sparse symmetric matrix of invalid dimension is specified.</cmnt>
  </c>
  <c name="MSK_RES_ERR_INVALID_FILE_FORMAT_FOR_SYM_MAT" val="4000">
   <cmnt>The file format does not support a problem with symmetric matrix variables.</cmnt>
  </c>
  <c name="MSK_RES_ERR_INVALID_FILE_FORMAT_FOR_CFIX" val="4001">
   <cmnt>The file format does not support a problem with nonzero fixed term in c.</cmnt>
  </c>
  <c name="MSK_RES_ERR_INVALID_FILE_FORMAT_FOR_RANGED_CONSTRAINTS" val="4002">
   <cmnt>The file format does not support a problem with ranged constraints.</cmnt>
  </c>
  <c name="MSK_RES_ERR_INVALID_FILE_FORMAT_FOR_FREE_CONSTRAINTS" val="4003">
   <cmnt>The file format does not support a problem with free constraints.</cmnt>
  </c>
  <c name="MSK_RES_ERR_INVALID_FILE_FORMAT_FOR_CONES" val="4005">
   <cmnt>The file format does not support a problem with conic constraints.</cmnt>
  </c>
  <c name="MSK_RES_ERR_INVALID_FILE_FORMAT_FOR_NONLINEAR" val="4010">
   <cmnt>The file format does not support a problem with nonlinear terms.</cmnt>
  </c>
  <c name="MSK_RES_ERR_DUPLICATE_CONSTRAINT_NAMES" val="4500">
   <cmnt>Two constraint names are identical.</cmnt>
  </c>
  <c name="MSK_RES_ERR_DUPLICATE_VARIABLE_NAMES" val="4501">
   <cmnt>Two variable names are identical.</cmnt>
  </c>
  <c name="MSK_RES_ERR_DUPLICATE_BARVARIABLE_NAMES" val="4502">
   <cmnt>Two barvariable names are identical.</cmnt>
  </c>
  <c name="MSK_RES_ERR_DUPLICATE_CONE_NAMES" val="4503">
   <cmnt>Two cone names are identical.</cmnt>
  </c>
  <c name="MSK_RES_ERR_NON_UNIQUE_ARRAY" val="5000">
   <cmnt>An array does not contain unique elements.</cmnt>
  </c>
  <c name="MSK_RES_ERR_ARGUMENT_IS_TOO_LARGE" val="5005">
   <cmnt>The value of a function argument is too large.</cmnt>
  </c>
  <c name="MSK_RES_ERR_MIO_INTERNAL" val="5010">
   <cmnt>A fatal error occurred in the mixed integer optimizer. Please contact |mosek| support.</cmnt>
  </c>
  <c name="MSK_RES_ERR_INVALID_PROBLEM_TYPE" val="6000">
   <cmnt>An invalid problem type.</cmnt>
  </c>
  <c name="MSK_RES_ERR_UNHANDLED_SOLUTION_STATUS" val="6010">
   <cmnt>Unhandled solution status.</cmnt>
  </c>
  <c name="MSK_RES_ERR_UPPER_TRIANGLE" val="6020">
   <cmnt>An element in the upper triangle of a lower triangular matrix is specified.</cmnt>
  </c>
  <c name="MSK_RES_ERR_LAU_SINGULAR_MATRIX" val="7000">
   <cmnt>A matrix is singular.</cmnt>
  </c>
  <c name="MSK_RES_ERR_LAU_NOT_POSITIVE_DEFINITE" val="7001">
   <cmnt>A matrix is not positive definite.</cmnt>
  </c>
  <c name="MSK_RES_ERR_LAU_INVALID_LOWER_TRIANGULAR_MATRIX" val="7002">
   <cmnt>An invalid lower triangular matrix.</cmnt>
  </c>
  <c name="MSK_RES_ERR_LAU_UNKNOWN" val="7005">
   <cmnt>An unknown error.</cmnt>
  </c>
  <c name="MSK_RES_ERR_LAU_ARG_M" val="7010">
   <cmnt>Invalid argument m.</cmnt>
  </c>
  <c name="MSK_RES_ERR_LAU_ARG_N" val="7011">
   <cmnt>Invalid argument n.</cmnt>
  </c>
  <c name="MSK_RES_ERR_LAU_ARG_K" val="7012">
   <cmnt>Invalid argument k.</cmnt>
  </c>
  <c name="MSK_RES_ERR_LAU_ARG_TRANSA" val="7015">
   <cmnt>Invalid argument transa.</cmnt>
  </c>
  <c name="MSK_RES_ERR_LAU_ARG_TRANSB" val="7016">
   <cmnt>Invalid argument transb.</cmnt>
  </c>
  <c name="MSK_RES_ERR_LAU_ARG_UPLO" val="7017">
   <cmnt>Invalid argument uplo.</cmnt>
  </c>
  <c name="MSK_RES_ERR_LAU_ARG_TRANS" val="7018">
   <cmnt>Invalid argument trans.</cmnt>
  </c>
  <c name="MSK_RES_ERR_LAU_INVALID_SPARSE_SYMMETRIC_MATRIX" val="7019">
   <cmnt>An invalid sparse symmetric matrix is specfified. Note only the lower triangular part with no duplicates is specifed.</cmnt>
  </c>
  <c name="MSK_RES_ERR_CBF_PARSE" val="7100">
   <cmnt>An error occurred while parsing an CBF file.</cmnt>
  </c>
  <c name="MSK_RES_ERR_CBF_OBJ_SENSE" val="7101">
   <cmnt>An invalid objective sense is specified.</cmnt>
  </c>
  <c name="MSK_RES_ERR_CBF_NO_VARIABLES" val="7102">
   <cmnt>No variables are specified.</cmnt>
  </c>
  <c name="MSK_RES_ERR_CBF_TOO_MANY_CONSTRAINTS" val="7103">
   <cmnt>Too many constraints specified.</cmnt>
  </c>
  <c name="MSK_RES_ERR_CBF_TOO_MANY_VARIABLES" val="7104">
   <cmnt>Too many variables specified.</cmnt>
  </c>
  <c name="MSK_RES_ERR_CBF_NO_VERSION_SPECIFIED" val="7105">
   <cmnt>No version specified.</cmnt>
  </c>
  <c name="MSK_RES_ERR_CBF_SYNTAX" val="7106">
   <cmnt>Invalid syntax.</cmnt>
  </c>
  <c name="MSK_RES_ERR_CBF_DUPLICATE_OBJ" val="7107">
   <cmnt>Duplicate OBJ keyword.</cmnt>
  </c>
  <c name="MSK_RES_ERR_CBF_DUPLICATE_CON" val="7108">
   <cmnt>Duplicate CON keyword.</cmnt>
  </c>
  <c name="MSK_RES_ERR_CBF_DUPLICATE_VAR" val="7109">
   <cmnt>Duplicate VAR keyword.</cmnt>
  </c>
  <c name="MSK_RES_ERR_CBF_DUPLICATE_INT" val="7110">
   <cmnt>Duplicate INT keyword.</cmnt>
  </c>
  <c name="MSK_RES_ERR_CBF_INVALID_VAR_TYPE" val="7111">
   <cmnt>Invalid variable type.</cmnt>
  </c>
  <c name="MSK_RES_ERR_CBF_INVALID_CON_TYPE" val="7112">
   <cmnt>Invalid constraint type.</cmnt>
  </c>
  <c name="MSK_RES_ERR_CBF_INVALID_DOMAIN_DIMENSION" val="7113">
   <cmnt>Invalid domain dimension.</cmnt>
  </c>
  <c name="MSK_RES_ERR_CBF_DUPLICATE_OBJACOORD" val="7114">
   <cmnt>Duplicate index in OBJCOORD.</cmnt>
  </c>
  <c name="MSK_RES_ERR_CBF_DUPLICATE_BCOORD" val="7115">
   <cmnt>Duplicate index in BCOORD.</cmnt>
  </c>
  <c name="MSK_RES_ERR_CBF_DUPLICATE_ACOORD" val="7116">
   <cmnt>Duplicate index in ACOORD.</cmnt>
  </c>
  <c name="MSK_RES_ERR_CBF_TOO_FEW_VARIABLES" val="7117">
   <cmnt>Too few variables defined.</cmnt>
  </c>
  <c name="MSK_RES_ERR_CBF_TOO_FEW_CONSTRAINTS" val="7118">
   <cmnt>Too few constraints defined.</cmnt>
  </c>
  <c name="MSK_RES_ERR_CBF_TOO_FEW_INTS" val="7119">
   <cmnt>Too few ints are specified.</cmnt>
  </c>
  <c name="MSK_RES_ERR_CBF_TOO_MANY_INTS" val="7120">
   <cmnt>Too many ints are specified.</cmnt>
  </c>
  <c name="MSK_RES_ERR_CBF_INVALID_INT_INDEX" val="7121">
   <cmnt>Invalid INT index.</cmnt>
  </c>
  <c name="MSK_RES_ERR_CBF_UNSUPPORTED" val="7122">
   <cmnt>Unsupported feature is present.</cmnt>
  </c>
  <c name="MSK_RES_ERR_CBF_DUPLICATE_PSDVAR" val="7123">
   <cmnt>Duplicate PSDVAR keyword.</cmnt>
  </c>
  <c name="MSK_RES_ERR_CBF_INVALID_PSDVAR_DIMENSION" val="7124">
   <cmnt>Invalid PSDVAR dimension.</cmnt>
  </c>
  <c name="MSK_RES_ERR_CBF_TOO_FEW_PSDVAR" val="7125">
   <cmnt>Too few variables defined.</cmnt>
  </c>
  <c name="MSK_RES_ERR_CBF_INVALID_EXP_DIMENSION" val="7126">
   <cmnt>Invalid dimension of a exponential cone.</cmnt>
  </c>
  <c name="MSK_RES_ERR_CBF_DUPLICATE_POW_CONES" val="7130">
   <cmnt>Multiple POWCONES specified.</cmnt>
  </c>
  <c name="MSK_RES_ERR_CBF_DUPLICATE_POW_STAR_CONES" val="7131">
   <cmnt>Multiple POW*CONES specified.</cmnt>
  </c>
  <c name="MSK_RES_ERR_CBF_INVALID_POWER" val="7132">
   <cmnt>Invalid power specified.</cmnt>
  </c>
  <c name="MSK_RES_ERR_CBF_POWER_CONE_IS_TOO_LONG" val="7133">
   <cmnt>Power cone is too long.</cmnt>
  </c>
  <c name="MSK_RES_ERR_CBF_INVALID_POWER_CONE_INDEX" val="7134">
   <cmnt>Invalid power cone index.</cmnt>
  </c>
  <c name="MSK_RES_ERR_CBF_INVALID_POWER_STAR_CONE_INDEX" val="7135">
   <cmnt>Invalid power star cone index.</cmnt>
  </c>
  <c name="MSK_RES_ERR_CBF_UNHANDLED_POWER_CONE_TYPE" val="7136">
   <cmnt>An unhandled power cone type.</cmnt>
  </c>
  <c name="MSK_RES_ERR_CBF_UNHANDLED_POWER_STAR_CONE_TYPE" val="7137">
   <cmnt>An unhandled power star cone type.</cmnt>
  </c>
  <c name="MSK_RES_ERR_CBF_POWER_CONE_MISMATCH" val="7138">
   <cmnt>The power cone does not match with it definition.</cmnt>
  </c>
  <c name="MSK_RES_ERR_CBF_POWER_STAR_CONE_MISMATCH" val="7139">
   <cmnt>The power star cone does not match with it definition.</cmnt>
  </c>
  <c name="MSK_RES_ERR_CBF_INVALID_NUMBER_OF_CONES" val="7740">
   <cmnt>Invalid number of cones.</cmnt>
  </c>
  <c name="MSK_RES_ERR_CBF_INVALID_DIMENSION_OF_CONES" val="7741">
   <cmnt>Invalid dimension of cones.</cmnt>
  </c>
  <c name="MSK_RES_ERR_MIO_INVALID_ROOT_OPTIMIZER" val="7700">
   <cmnt>An invalid root optimizer was selected for the problem type.</cmnt>
  </c>
  <c name="MSK_RES_ERR_MIO_INVALID_NODE_OPTIMIZER" val="7701">
   <cmnt>An invalid node optimizer was selected for the problem type.</cmnt>
  </c>
  <c name="MSK_RES_ERR_TOCONIC_CONSTR_Q_NOT_PSD" val="7800">
   <cmnt>The matrix defining the quadratric part of constraint is not positive semidefinite.</cmnt>
  </c>
  <c name="MSK_RES_ERR_TOCONIC_CONSTRAINT_FX" val="7801">
   <cmnt>The quadratic constraint is an equality, thus not convex.</cmnt>
  </c>
  <c name="MSK_RES_ERR_TOCONIC_CONSTRAINT_RA" val="7802">
   <cmnt>The quadratic constraint has finite lower and upper bound, and therefore it is not convex.</cmnt>
  </c>
  <c name="MSK_RES_ERR_TOCONIC_CONSTR_NOT_CONIC" val="7803">
   <cmnt>The constraint is not conic representable.</cmnt>
  </c>
  <c name="MSK_RES_ERR_TOCONIC_OBJECTIVE_NOT_PSD" val="7804">
   <cmnt>The matrix defining the quadratric part of the objective function is not positive semidefinite.</cmnt>
  </c>
  <c name="MSK_RES_ERR_SERVER_CONNECT" val="8000">
   <cmnt>Failed to connect to remote solver server. The server
string or the port string were invalid, or the server
did not accept connection.</cmnt>
  </c>
  <c name="MSK_RES_ERR_SERVER_PROTOCOL" val="8001">
   <cmnt>Unexpected message or data from solver server.</cmnt>
  </c>
  <c name="MSK_RES_ERR_SERVER_STATUS" val="8002">
   <cmnt>Server returned non-ok HTTP status code</cmnt>
  </c>
  <c name="MSK_RES_ERR_SERVER_TOKEN" val="8003">
   <cmnt>The job ID specified is incorrect or invalid</cmnt>
  </c>
  <c name="MSK_RES_ERR_SERVER_PROBLEM_SIZE" val="8008">
   <cmnt>The size of the problem exceeds the dimensions permitted by the instance of the |optserver| where it was run.</cmnt>
  </c>
  <c name="MSK_RES_TRM_MAX_ITERATIONS" val="10000">
   <cmnt>The optimizer terminated at the maximum number of iterations.</cmnt>
  </c>
  <c name="MSK_RES_TRM_MAX_TIME" val="10001">
   <cmnt>The optimizer terminated at the maximum amount of time.</cmnt>
  </c>
  <c name="MSK_RES_TRM_OBJECTIVE_RANGE" val="10002">
   <cmnt>The optimizer terminated with an objective value outside the objective range.</cmnt>
  </c>
  <c name="MSK_RES_TRM_MIO_NUM_RELAXS" val="10008">
   <cmnt>The mixed-integer optimizer terminated as the maximum number of relaxations was reached.</cmnt>
  </c>
  <c name="MSK_RES_TRM_MIO_NUM_BRANCHES" val="10009">
   <cmnt>The mixed-integer optimizer terminated as the maximum number of branches was reached.</cmnt>
  </c>
  <c name="MSK_RES_TRM_NUM_MAX_NUM_INT_SOLUTIONS" val="10015">
   <cmnt>The mixed-integer optimizer terminated as the maximum number of feasible solutions was reached.</cmnt>
  </c>
  <c name="MSK_RES_TRM_STALL" val="10006">
   <cmnt>The optimizer is terminated due to slow progress.

Stalling means that numerical problems prevent the optimizer from
making reasonable progress and that it makes no sense to continue.
In many cases this happens if the problem is badly scaled or
otherwise ill-conditioned. There is no guarantee that the
solution will be feasible or optimal. However, often
stalling happens near the optimum, and the returned solution may
be of good quality. Therefore, it is recommended to check the
status of the solution. If the solution status is optimal the solution is
most likely good enough for most practical purposes.

Please note that if a linear optimization problem is solved using
the interior-point optimizer with basis identification turned on,
the returned basic solution likely to have high accuracy, even though
the optimizer stalled.

Some common causes of stalling are a) badly scaled models, b)
near feasible or near infeasible problems.</cmnt>
  </c>
  <c name="MSK_RES_TRM_USER_CALLBACK" val="10007">
   <cmnt>The optimizer terminated due to the return of
the user-defined callback function.</cmnt>
  </c>
  <c name="MSK_RES_TRM_MAX_NUM_SETBACKS" val="10020">
   <cmnt>The optimizer terminated as the maximum number of set-backs was reached.
This indicates serious numerical problems and a possibly badly formulated problem.</cmnt>
  </c>
  <c name="MSK_RES_TRM_NUMERICAL_PROBLEM" val="10025">
   <cmnt>The optimizer terminated due to numerical problems.</cmnt>
  </c>
  <c name="MSK_RES_TRM_INTERNAL" val="10030">
   <cmnt>The optimizer terminated due to some internal reason. Please contact |mosek| support.</cmnt>
  </c>
  <c name="MSK_RES_TRM_INTERNAL_STOP" val="10031">
   <cmnt>The optimizer terminated for internal reasons. Please contact |mosek| support.</cmnt>
  </c>
 </sec>
 <sec id="MSKrescodetypee" type="enum">
  <cmnt>Response code type</cmnt>
  <c name="MSK_RESPONSE_OK" val="0">
   <cmnt>The response code is OK.</cmnt>
  </c>
  <c name="MSK_RESPONSE_WRN" val="1">
   <cmnt>The response code is a warning.</cmnt>
  </c>
  <c name="MSK_RESPONSE_TRM" val="2">
   <cmnt>The response code is an optimizer termination status.</cmnt>
  </c>
  <c name="MSK_RESPONSE_ERR" val="3">
   <cmnt>The response code is an error.</cmnt>
  </c>
  <c name="MSK_RESPONSE_UNK" val="4">
   <cmnt>The response code does not belong to any class.</cmnt>
  </c>
 </sec>
 <sec id="MSKscalingtypee" type="constants">
  <cmnt>Scaling type</cmnt>
  <c name="MSK_SCALING_FREE" val="0">
   <cmnt>The optimizer chooses the scaling heuristic.</cmnt>
  </c>
  <c name="MSK_SCALING_NONE" val="1">
   <cmnt>No scaling is performed.</cmnt>
  </c>
  <c name="MSK_SCALING_MODERATE" val="2">
   <cmnt>A conservative scaling is performed.</cmnt>
  </c>
  <c name="MSK_SCALING_AGGRESSIVE" val="3">
   <cmnt>A very aggressive scaling is performed.</cmnt>
  </c>
 </sec>
 <sec id="MSKscalingmethode" type="constants">
  <cmnt>Scaling method</cmnt>
  <c name="MSK_SCALING_METHOD_POW2" val="0">
   <cmnt>Scales only with power of 2 leaving the mantissa untouched.</cmnt>
  </c>
  <c name="MSK_SCALING_METHOD_FREE" val="1">
   <cmnt>The optimizer chooses the scaling heuristic.</cmnt>
  </c>
 </sec>
 <sec id="MSKsensitivitytypee" type="constants">
  <cmnt>Sensitivity types</cmnt>
  <c name="MSK_SENSITIVITY_TYPE_BASIS" val="0">
   <cmnt>Basis sensitivity analysis is performed.</cmnt>
  </c>
 </sec>
 <sec id="MSKsimseltypee" type="constants">
  <cmnt>Simplex selection strategy</cmnt>
  <c name="MSK_SIM_SELECTION_FREE" val="0">
   <cmnt>The optimizer chooses the pricing strategy.</cmnt>
  </c>
  <c name="MSK_SIM_SELECTION_FULL" val="1">
   <cmnt>The optimizer uses full pricing.</cmnt>
  </c>
  <c name="MSK_SIM_SELECTION_ASE" val="2">
   <cmnt>The optimizer uses approximate steepest-edge pricing.</cmnt>
  </c>
  <c name="MSK_SIM_SELECTION_DEVEX" val="3">
   <cmnt>The optimizer uses devex steepest-edge pricing (or if it is not available an approximate steep-edge selection).</cmnt>
  </c>
  <c name="MSK_SIM_SELECTION_SE" val="4">
   <cmnt>The optimizer uses steepest-edge selection (or if it is not available an approximate steep-edge selection).</cmnt>
  </c>
  <c name="MSK_SIM_SELECTION_PARTIAL" val="5">
   <cmnt>The optimizer uses a partial selection approach. The approach is usually beneficial if the number of variables is much larger than  the number of constraints.</cmnt>
  </c>
 </sec>
 <sec id="MSKsoliteme" type="enum">
  <cmnt>Solution items</cmnt>
  <c name="MSK_SOL_ITEM_XC" val="0">
   <cmnt>Solution for the constraints.</cmnt>
  </c>
  <c name="MSK_SOL_ITEM_XX" val="1">
   <cmnt>Variable solution.</cmnt>
  </c>
  <c name="MSK_SOL_ITEM_Y" val="2">
   <cmnt>Lagrange multipliers for equations.</cmnt>
  </c>
  <c name="MSK_SOL_ITEM_SLC" val="3">
   <cmnt>Lagrange multipliers for lower bounds on the constraints.</cmnt>
  </c>
  <c name="MSK_SOL_ITEM_SUC" val="4">
   <cmnt>Lagrange multipliers for upper bounds on the constraints.</cmnt>
  </c>
  <c name="MSK_SOL_ITEM_SLX" val="5">
   <cmnt>Lagrange multipliers for lower bounds on the variables.</cmnt>
  </c>
  <c name="MSK_SOL_ITEM_SUX" val="6">
   <cmnt>Lagrange multipliers for upper bounds on the variables.</cmnt>
  </c>
  <c name="MSK_SOL_ITEM_SNX" val="7">
   <cmnt>Lagrange multipliers corresponding to the conic constraints on the variables.</cmnt>
  </c>
 </sec>
 <sec id="MSKsolstae" type="enum">
  <cmnt>Solution status keys</cmnt>
  <c name="MSK_SOL_STA_UNKNOWN" val="0">
   <cmnt>Status of the solution is unknown.</cmnt>
  </c>
  <c name="MSK_SOL_STA_OPTIMAL" val="1">
   <cmnt>The solution is optimal.</cmnt>
  </c>
  <c name="MSK_SOL_STA_PRIM_FEAS" val="2">
   <cmnt>The solution is primal feasible.</cmnt>
  </c>
  <c name="MSK_SOL_STA_DUAL_FEAS" val="3">
   <cmnt>The solution is dual feasible.</cmnt>
  </c>
  <c name="MSK_SOL_STA_PRIM_AND_DUAL_FEAS" val="4">
   <cmnt>The solution is both primal and dual feasible.</cmnt>
  </c>
  <c name="MSK_SOL_STA_PRIM_INFEAS_CER" val="5">
   <cmnt>The solution is a certificate of primal infeasibility.</cmnt>
  </c>
  <c name="MSK_SOL_STA_DUAL_INFEAS_CER" val="6">
   <cmnt>The solution is a certificate of dual infeasibility.</cmnt>
  </c>
  <c name="MSK_SOL_STA_PRIM_ILLPOSED_CER" val="7">
   <cmnt>The solution is a certificate that the primal problem is illposed.</cmnt>
  </c>
  <c name="MSK_SOL_STA_DUAL_ILLPOSED_CER" val="8">
   <cmnt>The solution is a certificate that the dual problem is illposed.</cmnt>
  </c>
  <c name="MSK_SOL_STA_INTEGER_OPTIMAL" val="9">
   <cmnt>The primal solution is integer optimal.</cmnt>
  </c>
 </sec>
 <sec id="MSKsoltypee" type="enum">
  <cmnt>Solution types</cmnt>
  <c name="MSK_SOL_BAS" val="1">
   <cmnt>The basic solution.</cmnt>
  </c>
  <c name="MSK_SOL_ITR" val="0">
   <cmnt>The interior solution.</cmnt>
  </c>
  <c name="MSK_SOL_ITG" val="2">
   <cmnt>The integer solution.</cmnt>
  </c>
 </sec>
 <sec id="MSKsolveforme" type="constants">
  <cmnt>Solve primal or dual form</cmnt>
  <c name="MSK_SOLVE_FREE" val="0">
   <cmnt>The optimizer is free to solve either the primal or the dual problem.</cmnt>
  </c>
  <c name="MSK_SOLVE_PRIMAL" val="1">
   <cmnt>The optimizer should solve the primal problem.</cmnt>
  </c>
  <c name="MSK_SOLVE_DUAL" val="2">
   <cmnt>The optimizer should solve the dual problem.</cmnt>
  </c>
 </sec>
 <sec id="MSKsparame" type="parameters">
  <cmnt>The enumeration type containing all string parameters.</cmnt>
  <p name="MSK_SPAR_DATA_FILE_NAME" val="1">
   <cmnt>Data are read and written to this file.</cmnt>
   <default>""</default>
  </p>
  <p name="MSK_SPAR_PARAM_READ_FILE_NAME" val="7">
   <cmnt>Modifications to the parameter database is read from this file.</cmnt>
   <default>""</default>
  </p>
  <p name="MSK_SPAR_PARAM_WRITE_FILE_NAME" val="8">
   <cmnt>The parameter database is written to this file.</cmnt>
   <default>""</default>
  </p>
  <p name="MSK_SPAR_PARAM_COMMENT_SIGN" val="6">
   <cmnt>Only the first character in this string is
used. It is considered as a start of comment sign
in the |mosek| parameter file. Spaces are ignored
in the string.</cmnt>
   <default>"%%"</default>
  </p>
  <p name="MSK_SPAR_DEBUG_FILE_NAME" val="2">
   <cmnt>|mosek| debug file.</cmnt>
   <default>""</default>
  </p>
  <p name="MSK_SPAR_BAS_SOL_FILE_NAME" val="0">
   <cmnt>Name of the ``bas`` solution file.</cmnt>
   <default>""</default>
  </p>
  <p name="MSK_SPAR_ITR_SOL_FILE_NAME" val="4">
   <cmnt>Name of the ``itr`` solution file.</cmnt>
   <default>""</default>
  </p>
  <p name="MSK_SPAR_INT_SOL_FILE_NAME" val="3">
   <cmnt>Name of the ``int`` solution file.</cmnt>
   <default>""</default>
  </p>
  <p name="MSK_SPAR_SOL_FILTER_XC_LOW" val="16">
   <cmnt>A filter used to determine which constraints should be listed in the solution file. A value of :math:`0.5` means that all constraints having  ``xc[i]&gt;0.5`` should be listed, whereas ``+0.5`` means that all constraints having ``xc[i]&gt;=blc[i]+0.5`` should be listed. An empty filter means that no filter is applied.</cmnt>
   <default>""</default>
  </p>
  <p name="MSK_SPAR_SOL_FILTER_XC_UPR" val="17">
   <cmnt>A filter  used to determine which constraints should be listed in the solution file. A value of ``0.5`` means that all constraints having ``xc[i]&lt;0.5`` should be listed, whereas ``-0.5`` means all constraints having ``xc[i]&lt;=buc[i]-0.5`` should be listed. An empty filter means that no filter is applied.</cmnt>
   <default>""</default>
  </p>
  <p name="MSK_SPAR_SOL_FILTER_XX_LOW" val="18">
   <cmnt>A filter  used to determine which variables should be listed in the solution file. A value of "0.5" means that all constraints having ``xx[j]&gt;=0.5`` should be listed, whereas "+0.5" means that all constraints having ``xx[j]&gt;=blx[j]+0.5`` should be listed. An empty filter means no filter is applied.</cmnt>
   <default>""</default>
  </p>
  <p name="MSK_SPAR_SOL_FILTER_XX_UPR" val="19">
   <cmnt>A filter  used to determine which variables should be listed in the solution file. A value of "0.5" means that all constraints having ``xx[j]&lt;0.5`` should be printed, whereas "-0.5" means all constraints having ``xx[j]&lt;=bux[j]-0.5`` should be listed. An empty filter means no filter is applied.</cmnt>
   <default>""</default>
  </p>
  <p name="MSK_SPAR_READ_MPS_OBJ_NAME" val="10">
   <cmnt>Name of the free constraint used as objective function.
An empty name means that the first constraint is used as objective function.</cmnt>
   <default>""</default>
  </p>
  <p name="MSK_SPAR_READ_MPS_RAN_NAME" val="11">
   <cmnt>Name of the RANGE vector  used. An empty name means that the first RANGE vector is used.</cmnt>
   <default>""</default>
  </p>
  <p name="MSK_SPAR_READ_MPS_RHS_NAME" val="12">
   <cmnt>Name of the RHS used. An empty name means that the first RHS vector is used.</cmnt>
   <default>""</default>
  </p>
  <p name="MSK_SPAR_READ_MPS_BOU_NAME" val="9">
   <cmnt>Name of the BOUNDS vector used. An empty name means that the first BOUNDS vector is used.</cmnt>
   <default>""</default>
  </p>
  <p name="MSK_SPAR_STAT_FILE_NAME" val="20">
   <cmnt>Statistics file name.</cmnt>
   <default>""</default>
  </p>
  <p name="MSK_SPAR_STAT_NAME" val="22">
   <cmnt>Name used when writing the statistics file.</cmnt>
   <default>""</default>
  </p>
  <p name="MSK_SPAR_STAT_KEY" val="21">
   <cmnt>Key used when writing the summary file.</cmnt>
   <default>""</default>
  </p>
  <p name="MSK_SPAR_WRITE_LP_GEN_VAR_NAME" val="23">
   <cmnt>Sometimes when an LP file is written additional variables must be inserted.
They will have the prefix denoted by this parameter.</cmnt>
   <default>"xmskgen"</default>
  </p>
  <p name="MSK_SPAR_SENSITIVITY_RES_FILE_NAME" val="15">
   <cmnt>.. msk_only:: cmdtools

   Not applicable.

.. msk_only:: optimizer

   If this is a nonempty string, then :msk:func:`task.sensitivityreport` writes results to this file.</cmnt>
   <default>""</default>
  </p>
  <p name="MSK_SPAR_SENSITIVITY_FILE_NAME" val="14">
   <cmnt>.. msk_only:: cmdtools

   Not applicable.

.. msk_only:: optimizer

   If defined :msk:func:`task.sensitivityreport` reads this file as
   a sensitivity analysis data file specifying the type of analysis to be done.

.. msk_only:: (not optimizer) and (not cmdtools)

   If defined, |mosek| reads this file as
   a sensitivity analysis data file specifying the type of analysis to be done.</cmnt>
   <default>""</default>
  </p>
  <p name="MSK_SPAR_MIO_DEBUG_STRING" val="5">
   <cmnt>For internal debugging purposes.</cmnt>
   <default>""</default>
  </p>
  <p name="MSK_SPAR_REMOTE_ACCESS_TOKEN" val="13">
   <cmnt>An access token used to submit tasks to a remote |mosek| server.
An access token is a random 32-byte string encoded in base64, i.e. it
is a 44 character ASCII string.</cmnt>
   <default>""</default>
  </p>
 </sec>
 <sec id="MSKstakeye" type="enum">
  <cmnt>Status keys</cmnt>
  <c name="MSK_SK_UNK" val="0">
   <cmnt>The status for the constraint or variable is unknown.</cmnt>
  </c>
  <c name="MSK_SK_BAS" val="1">
   <cmnt>The constraint or variable is in the basis.</cmnt>
  </c>
  <c name="MSK_SK_SUPBAS" val="2">
   <cmnt>The constraint or variable is super basic.</cmnt>
  </c>
  <c name="MSK_SK_LOW" val="3">
   <cmnt>The constraint or variable is at its lower bound.</cmnt>
  </c>
  <c name="MSK_SK_UPR" val="4">
   <cmnt>The constraint or variable is at its upper bound.</cmnt>
  </c>
  <c name="MSK_SK_FIX" val="5">
   <cmnt>The constraint or variable is fixed.</cmnt>
  </c>
  <c name="MSK_SK_INF" val="6">
   <cmnt>The constraint or variable is infeasible in the bounds.</cmnt>
  </c>
 </sec>
 <sec id="MSKstartpointtypee" type="constants">
  <cmnt>Starting point types</cmnt>
  <c name="MSK_STARTING_POINT_FREE" val="0">
   <cmnt>The starting point is chosen automatically.</cmnt>
  </c>
  <c name="MSK_STARTING_POINT_GUESS" val="1">
   <cmnt>The optimizer guesses a starting point.</cmnt>
  </c>
  <c name="MSK_STARTING_POINT_CONSTANT" val="2">
   <cmnt>The optimizer constructs a starting point by assigning a constant value to all primal and dual variables. This starting point is normally robust.</cmnt>
  </c>
  <c name="MSK_STARTING_POINT_SATISFY_BOUNDS" val="3">
   <cmnt>The starting point is chosen to satisfy all the simple bounds on nonlinear variables. If this starting point is employed, then more care than usual should employed when choosing the bounds on the nonlinear variables. In particular very tight bounds should be avoided.</cmnt>
  </c>
 </sec>
 <sec id="MSKstreamtypee" type="enum">
  <cmnt>Stream types</cmnt>
  <c name="MSK_STREAM_LOG" val="0">
   <cmnt>Log stream. Contains the aggregated contents of all other streams. This means that a message written to any other stream will also be written to this stream.</cmnt>
  </c>
  <c name="MSK_STREAM_MSG" val="1">
   <cmnt>Message stream. Log information relating to performance and progress of the optimization is written to this stream.</cmnt>
  </c>
  <c name="MSK_STREAM_ERR" val="2">
   <cmnt>Error stream. Error messages are written to this stream.</cmnt>
  </c>
  <c name="MSK_STREAM_WRN" val="3">
   <cmnt>Warning stream. Warning messages are written to this stream.</cmnt>
  </c>
 </sec>
 <sec id="MSKvaluee" type="constants">
  <cmnt>Integer values</cmnt>
  <c name="MSK_MAX_STR_LEN" val="1024">
   <cmnt>Maximum string length allowed in |mosek|.</cmnt>
  </c>
  <c name="MSK_LICENSE_BUFFER_LENGTH" val="21">
   <cmnt>The length of a license key buffer.</cmnt>
  </c>
 </sec>
 <sec id="MSKvariabletypee" type="enum">
  <cmnt>Variable types</cmnt>
  <c name="MSK_VAR_TYPE_CONT" val="0">
   <cmnt>Is a continuous variable.</cmnt>
  </c>
  <c name="MSK_VAR_TYPE_INT" val="1">
   <cmnt>Is an integer variable.</cmnt>
  </c>
 </sec>
</constlist>
</mosekvalues>
